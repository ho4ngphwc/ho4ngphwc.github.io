---
layout: post
title:  "JWT Attack"
date:   2025-07-21 12:00:00 +0700
tags: PortSwigger
categories: jekyll update
---

# JWT Attacks 

JWT được viết tắt là Json Web Token, dùng để xác thực và cơ chế access control. Thường được ký bằng dữ liệu JSON giữa các hệ thống và được lưu trữ ở client-side. 

### JWT Format 
Được chia làm 3 phần: header, payload, và signature. Mỗi phần thì được tách ra bằng dấu `.`
![image](https://hackmd.io/_uploads/H1Z--frIxx.png)

Và thường thì nó sẽ được encode base64

### JWT Signature 
Signature hay còn gọi là chữ ký, thì thường server phát hành token thì thường sẽ kèm theo và sẽ được hash. Khi kí thì thường liên quan đến `secret signing`.

### JWT & JWS & JWE 
JWS là Jason Web Signature, JWE là Jason Web Encryption. Cả hai đều là mở rộng từ JWT. 

![image](https://hackmd.io/_uploads/SkdziNr8ex.png)

## Tấn công JWT 
Tấn công thường liên quan đến việc chỉnh sửa JWT và gửi tới Server để đạt được mục đích xấu. Mục tiêu là bypass authentication và kiểm soát user khác đã xác thực. 

## Tác động 
Attacker có thể tạo 1 token hợp lệ với các giá trị thuộc tính, từ đó có thể leo thang đặc quyền và kiểm soát quyền truy cập. 

## Nguồn gốc từ đâu phát sinh ra bug JWT? 
- Thường là do xử lý thiếu sót trong chính ứng dụng đó. 
- Có thể là do lập trình viên không xử lý ổn giữa các JWT vì cũng còn có JWS và JWE
- Kẻ tấn công thường truyền vào phần payload của JWT, ngay cả khi là được xác thực mạnh mẽ => khóa có thể bị rò rỉ, có thể đoán hoặc bắt buộc kẻ tấn công tạo ra 1 JWT hợp lệ.

## Khai thác xác thực thiếu sót JWT Signature 
- JWT thường không được lưu trữ trên server - tức là server không nhớ token nào đã phát hành. 
- Token tự chứa toàn bộ thông tin (dữ liệu và chứ ký)
Ưu điểm: không cần lưu trạng thái trên server, dễ mở rộng.
Nhược điểm: Nếu server không kiểm tra chữ ký đúng cách, thì ai đó có thể sửa thoải mái và server không phát hiện. 

![image](https://hackmd.io/_uploads/rkUJEsvIeg.png)
Nếu mà server dùng `username` để xác định phiên và `isAdmin` để xác định vai trò của user. Như vậy thì dễ dẫn tới leo thang đặc quyền,

### Server chấp nhận bất kỳ chữ ký nào - 'ko hợp lệ hoặc kẻ tấn công tạo ra'
Các thư viện JWT thường có 2 hàm: 
- `verify(token, key)` -> giải mã và kiểm tra chữ ký (đảm bảo token hợp lệ, không bị sửa)
- `decode(token)` -> chỉ giải mã phần payload, không kiểm  tra chữ ký

#### LAB01
Lúc đầu mình login vào 1 account có tên là `wiener`

![image](https://hackmd.io/_uploads/r1g3IsDUle.png)

Quan sát thì sẽ có 1 JWT sinh ra. 

![image](https://hackmd.io/_uploads/S1M9PiPUeg.png)

Thì nếu server lại ko nghiêm ngặt thì mình hoàn toàn có thể sửa lại bằng `administrator`

![image](https://hackmd.io/_uploads/S1_yOiv8xl.png)

Sau đó, có thể truy cập vào `id=administrator`

![image](https://hackmd.io/_uploads/BkLXdowIex.png)

### Server chấp nhận token không có signature
Trong JWT header bao gồm tham số `alg` - algorithm.
- Trường này chỉ ra thuật toán được dùng để ký token. 
- Khi server nhận được token, nó sẽ đọc `alg` và dùng thuật toán tương ứng để kiểm tra chữ ký. 

![image](https://hackmd.io/_uploads/BJ8I9owUel.png)

Server tin tưởng quá sớm vào nội dung của JWT - đặc biệt là trường `alg`.
Attacker có thể lừa server bỏ qua việc xác minh, ví dụ bằng cách dùng `alg:none` và làm rối nội dung. 

#### LAB02
Mình login vào 1 tài khoản, sẽ được sinh ra 1 token JWT. 

![image](https://hackmd.io/_uploads/rkKpisP8gx.png)

Mình có thể thao tác vào tham số `alg`

![image](https://hackmd.io/_uploads/Bkqb43vLel.png)

Sau đó, mình truy cập vào `id=administrator`

![image](https://hackmd.io/_uploads/SyEuEnDLeg.png)

## Brute-forcing secret keys 
Thuật toán dùng để ký token, ví dụ HS256(HMAC + SHA-256) => thì secret key là 1 chuỗi. 
Như vậy, nếu attacker đoán được secret key của HS256, có thể tạo JWT giả mạo với chữ ký hợp lệ => có thể bypass xác thực. Wordlist để brute-force ở đây: https://github.com/wallarm/jwt-secrets/blob/master/jwt.secrets.list.

### Brute-forcing secret keys dùng hashcat 

Mình dùng hashcat để bruteforce

![image](https://hackmd.io/_uploads/S1J043dIel.png)

#### LAB03
Khi login vào 1 tài khoản thì được sinh ra 1 JWT như sau: 
![image](https://hackmd.io/_uploads/BycwSh_Ile.png)

Sau đó, mình đem đi cho hashcat crack
![image](https://hackmd.io/_uploads/By-qBnOUgg.png)

Và tìm ra được chuỗi là `secret1`

Tiếp theo, sẽ đem đi encode base64 để có thể tự ký lại cho token của mình. 

![image](https://hackmd.io/_uploads/H1hiwndUle.png)

![image](https://hackmd.io/_uploads/SJRaw3d8xe.png)

Sau đó, ký lại thì mình đã có 1 token mới và hợp lệ dưới quyền administrator.

![image](https://hackmd.io/_uploads/SJZbd3_8le.png)

Truy cập vào `id=administrator`

![image](https://hackmd.io/_uploads/HyZPthdLee.png)

## Tiêm nhiễm tham số JWT header 
Trong header của JWT thì ngoài tham số `alg` thì nó còn có: 
- jwk: chứa key dưới dạng JSON nhúng vào trong token 
- jku: chứa URL đến file chứa public key, Server truy cập link này để lấy key và dùng nó xác minh token 
- kid: là tên định danh của key (Key ID), khi có nhiều key, server dùng `kid` để chọn đúng key để xác minh. 

### Tiêm nhiễm các JWT tự ký thông qua tham số jwk
jwk trong header dùng để nhúng khóa công khai vào trong JWT dưới định dạng JWK. 

```json
{
    "kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG",
    "typ": "JWT",
    "alg": "RS256",
    "jwk": {
        "kty": "RSA",
        "e": "AQAB",
        "kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG",
        "n": "yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9m"
    }
}
```

#### LAB04
Sau khi login vào 1 tài khoản thì mình được 1 JWT, sau đó mình tạo ra 1 khóa công khai như sau:

![image](https://hackmd.io/_uploads/BJ4WlauUgx.png)

Tiếp theo, mình nhúng khóa công khai này vào trong JWT của mình. 

![image](https://hackmd.io/_uploads/SJK4l6OIle.png)

Cuối cùng, sau khi chỉnh lại thành `administrator`, mình cần ký lại token để có tính hợp lệ. 

![image](https://hackmd.io/_uploads/r1f9g6uUxg.png)

Truy cập vào `id=adminstrator` hoàn toàn hợp lí. 

![image](https://hackmd.io/_uploads/Skkiep_Leg.png)

### Tiêm nhiễm các JWT tự ký thông qua tham số jku 
Thay vì nhúng public key vào trong tham số `jwk`, mà một vài server dùng `jku` để tham chiếu đến key. 

```json
{
    "keys": [
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "75d0ef47-af89-47a9-9061-7c02a610d5ab",
            "n": "o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ"
        },
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "d8fDFo-fS9-faS14a9-ASf99sa-7c1Ad5abA",
            "n": "fc3f-yy1wpYmffgXBxhAUJzHql79gNNQ_cb33HocCuJolwDqmk6GPM4Y_qTVX67WhsN3JvaFYw-dfg6DH-asAScw"
        }
    ]
}
```
JWK Sets (danh sách các public key) thường được công khai tại một endpoint chuẩn => `/.well-known/jwks.json`

#### LAB05

Khi login vào 1 account thì được sinh ra 1 JWT và sau đó mình tạo ra 1 key pair. 

![image](https://hackmd.io/_uploads/B1QqLTdUxl.png)

Sau đó, mình lưu trữ key lên 1 server của attacker, chính là khóa công khai đã tạo trước đó.

![image](https://hackmd.io/_uploads/BJvHPTd8gg.png)

Tiếp theo, mình thêm tham số `jku` dẫn đến server của attacker và cần chỉnh lại `kid` đúng với `kid` trong key đã tạo. 

![image](https://hackmd.io/_uploads/BJhIO6u8ex.png)

Sau đó, cần ký lại để mang tính hợp lệ và truy cập vào `id=adminstrator`

![image](https://hackmd.io/_uploads/SySYdTuUle.png)

### Tiêm nhiễm các JWT tự ký qua tham số kid 
Server thường dùng nhiều khóa khác nhau để ký các loại dữ liệu khác nhau, không chỉ JWT. 
JWT có thể chứa trường `kid` trong header => giúp server xác định nên dùng khóa nào để xác minh. 
```json 
{
    "kid": "../../path/to/file",
    "typ": "JWT",
    "alg": "HS256",
    "k": "asGsADas3421-dfh9DGN-AFDFDbasfd8-anfjkvc"
}
```
Điều này nguy hiểm với các server dùng khóa đối xứng, thì attacker sẽ dẫn tới các file,... có thể ký lại JWT hợp lệ. 
Thường thì có thể dẫn tới `/dev/null` thì nó trả về file rỗng mà việc ký với file rỗng thì hoàn toàn hợp lệ. 

#### LAB06 
Khi login thì có 1 JWT sinh ra, mà nó dùng khóa đối xứng. Cho nên mình sẽ tạo ra 1 khóa đối xứng có chứa key là `null` nhưng sẽ phải encoded Base64 `AA==`

![image](https://hackmd.io/_uploads/r1Vm2QsUgx.png)

Sau đó, mình phải ký lại token này nhưng với tham số `kid` dẫn tới `/dev/null`
![image](https://hackmd.io/_uploads/ByNqh7jUeg.png)

Cuối cùng, mình truy cập `id=administrator`

![image](https://hackmd.io/_uploads/ByRjnQjIgg.png)

### Các trường khác trong header cũng có thể lợi dụng 
1. `cty` - Content Type
- Dùng để chỉ kiểu nội dung của payload.
- Nếu vượt qua được kiểm tra chữ ký, attacker có thể thêm `cty: text/xml` hoặc `application/x-java-serialized-object` để kích hoạt các lỗ hổng như sau: 
    - XXE (XML Eternal Entity)
    - Deserialization
2. `x5c` - X.509 Certificate Chain 
- Chứa chứng chỉ công khai X.509 hoặc chuỗi chứng chỉ
- Có thể bị lợi dụng để chèn chứng chỉ tự ký, giống với tham số `jwk`
    - `CVE-2017-2800`
    - `CVE-2018-2633`

## Tấn công nhầm lẫn thuật toán
Khi server sử dụng secret mạnh (khó đoán), mình vẫn có thể giả mạo JWT hợp lệ nếu có thể thay đổi thuật toán ký (`alg`) trong header. 
- Thay đổi `alg` từ `RS256` (bất đối xứng) => `HS256` (đối xứng)
- Sau đó ký lại token bằng `public key như một secret`

## Lỗ hổng nhầm lẫn thuật toán xảy ra do đâu?
Một số thư viện JWT cho phép dùng một hàm kiểm tra chữ ký chung cho nhiều thuật toán. 
Hàm này tự động dựa vào giá trị `alg` trong JWT header để chọn cách xác minh chữ ký. 
Script ví dụ gây lỗ hổng.
```json=
function verify(token, secretOrPublicKey){
    algorithm = token.getAlgHeader();
    if(algorithm == "RS256"){
        // Use the provided key as an RSA public key
    } else if (algorithm == "HS256"){
        // Use the provided key as an HMAC secret key
    }
}
```

Một số lập trình viên nghĩ rằng hàm xác minh chữ ký trong thư viện JWT chỉ xử lý JWT dùng thuật toán bất đối xứng như `RS256`
Vì vậy luôn truyền public key vào hàm xác minh như:
```
publicKey = <public-key-of-server>;
token = request.getCookie("session");
verify(token, publicKey);
``` 

#### LAB07 
Thông thường thì server hay lưu trữ public key tại `jwks.json` hoặc `/.well-known/jwks.json`

![image](https://hackmd.io/_uploads/S1KRYEoLgg.png)

Sau đó, mình copy đoạn public key này lại. Và tạo ra 1 cặp khóa bất đối xứng khác. Với key là nội dung public đã copy. 

![image](https://hackmd.io/_uploads/ByjTcEoUge.png)

Sau đó chọn PEM, rồi copy lại. 

![image](https://hackmd.io/_uploads/ryj8i4i8lx.png)

Tiếp theo encoded public key này thành 1 chuỗi base64. Bước tiếp theo, tạo ra 1 khóa đối xứng với key là chuỗi đã encoded base64. 

![image](https://hackmd.io/_uploads/B1Zyp4jIge.png)

Cuối cùng, thì mình chỉnh sửa thuật toán thành `HS256`, và ký lại token này với khóa đối xứng. 


![image](https://hackmd.io/_uploads/rkOjp4oIxx.png)

Sau cùng thì truy cập `id=administrator`

![image](https://hackmd.io/_uploads/r1cj6NiLgg.png)

## Suy ra khóa công khai từ 1 JWT đã được cấp.

Ngay cả khi public key không được công khai, attacker vẫn có thể suy ra từ hai JWT hợp lệ để thực hiện tấn công nhầm lẫn thuật toán bằng cách `alg` từ `RS256` sang `HS256` và dùng public key làm HMAC secret. 
Công cụ như `jwt_forgery.py` trong repo `rsa_sign2n` hỗ trợ điều này. 

Link repo: https://github.com/silentsignal/rsa_sign2n

```bash=
docker run --rm -it portswigger/sig2n <token1> <token2>
```

Công cụ sẽ dùng các JWT mình cung cấp để tính ra nhiều giá trị `n` khả thi (thành phần của RSA key). 
Với mỗi giá trị, nó tạo ra khóa công khai (PEM) và JWT giả mạo tương ứng.

Mình chỉ cần dùng Burp Repeater để gửi từng JWT — cái nào được server chấp nhận chính là khóa đúng. 
Từ đó, mình có thể thực hiện tấn công nhầm lẫn thuật toán bằng cách dùng public key làm HMAC secret.

#### LAB08 

Đầu tiên cần chạy docker của repo đã cung cấp ở trên. 
Sau đó, mình login 2 lần để thu thập đủ 2 token. 

Rồi mình dùng tool đã dựng bằng docker như sau: 

![image](https://hackmd.io/_uploads/HJKOe8oUxl.png)

Mình sẽ thử hai token đã được cung cấp này: 

![image](https://hackmd.io/_uploads/HJibbUs8lg.png)

Thì chỉ có 1 token hoạt động là token đầu tiên. Và tool cũng đã viết ra thành 1 file có chứa public key rồi. 

![image](https://hackmd.io/_uploads/S1JfSUj8ll.png)

Mình lặp lại các bước như encoded base64 public key này, rồi tạo 1 khóa đối xứng. 

![image](https://hackmd.io/_uploads/Sy9S5LjIll.png)

## Khắc phục 
1. Dùng thư viện JWT mới nhất 
2. Luôn xác minh chữ ký và thuật toán
3. Chỉ cho phép domain tin cập trong `jku`
4. Sanitize `kid` để tránh Path Traversal / SQL injection

- Luôn đặt thời gian hết hạn (`exp`) cho token. 
- Không gửi token trong URL, dùng HTTP header thay thế
- Dùng `aud` (audience) để chỉ định token dành cho hệ thống nào. 
- Cho phép thu hồi token. 